#program gomummy
#autostart 10
#autoline 10,1
; Oh Mummy (clone) and to avoid any problem with the name, called Go Mummy!
; By Remy Sharp 2020 / @rem / https://remysharp.com
; Full source code at https://github.com/remy/next-go-mummy/
;
RUN AT 3: REM @ 28Mhz
;
; ******** TODO *********
; - [x] finish game \o/
;
; ******** VARIABLE INDEX *********
;
; %A[] = baddie array (allows for > 64 elements)
; %b = baddie index
; %c = baddie count
; %C[] = palette colours for tombs
; %d = player sprite flags (mirror, etc)
; H() = high scores (actually just one)
; %n = delta time counter (only used during dev, but needs to be reserved)
; %P() = 0=lives, 1=score, 2=score multiple, 3=has scroll, 4=player last corner, used for tomb calc - initilised to $FFFF
; %P = player last position, used for tread marks - initilised to $FFFF
; %q = player last direction (whilst movement is engaged) - used for movement hacks
; %r = (flag) player has scroll and can kill a mummy
; %s = player sprite
; %R() = used to pick random selection of hidden items
; %S(...) = speed option array
; %T(21) = tomb array 0-19 with index 20 used for temp rendering, with 8bit flags (14 items contain data in the low bit)
; %t = items to find - defaults to 2
; %x = player x
; %y = player y
; %z = speed (for both baddie and player)
; --- non int vars ---
; DIFFICULTY(3) = how many lives you start with
; LEVEL(1) = current level
; SPEED(3) = how fast the baddies are
; PLAYING = bool like - whether we're in game or not (in menus)
;
; TMP VARIABLES
; i, j, k (but often shared) - then - a, e, f, g, h, l, o, u, v, w (used for score math) (unless documented, are disposable between DEFPROCS)
;
; BANK INDEX
;
; 19: tiles (copied from BANK 23)
; 20: music (music.ndr)
; 21: game over (music) (gameover.ndr)
; 22: main player and NPC sprites (m-sprites.spr)
; 23: tile map (used with BANK 19) (mummy.map)
; 24: tile data (sprites) (m-tiles.spr)
; 25: hi score (music) (hiscore.ndr)
; 26: game over/pause tiles
; 27: tomb tiles - extra graphics arranged in a useful layout
; 28: palette - let's me change level colours without additional graphics
; 29: sound effects (mummy.afb)
; 30: temp holding space for 1/3rd of layer 2 screen (used for pause)
; 31-33: screen cover image
;
; SCORING
;
; A number of actions have base score values and depending on the speed and
; difficulty the player has selected, a multiple is applied.
;
; The multiple logic is: x => (d-1)+s:
; This works out so that (s)peed = 1 and (d)iffulty = 1 has a multiple of 1,
; and speed = 3 and diffulty = 3 has a multiple of 5.
;
; Action values:
; - level up: 50
; - reveal empty tomb: 1
; - reveal archaeologist: 25
; - reveal key: 25
; - reveal gold: 5
; - kill nasty: 10
;
; **********************************
;
;PROC dT()

DEBUG=0
SPRITEON=1
BOOT=0

IF NOT DEBUG THEN ON ERROR PROC exit()

PROC initOnce()
PROC initNewGame()
PROC mainLoop()

; game loop - includes: render loop, lives check & game over
DEFPROC mainLoop()
  REPEAT
    REPEAT
      ;IF DEBUG THEN IF INKEY$ ="s" THEN SPRITEON= NOT SPRITEON: SPRITE PRINT SPRITEON
      ;IF DEBUG THEN PRINT AT %1,%0;"mem=";%65536- USR 7962;" ": ; memory available....
      ;IF DEBUG THEN IF INKEY$ ="t" THEN %t=0: ; FIXME remove TESTING ONLY
      ;IF DEBUG THEN IF INKEY$ ="d" THEN %P(0)=0: ; FIXME remove TESTING ONLY
      ;IF DEBUG THEN IF INKEY$ ="w" THEN LEVEL=5:%t=0: ; FIXME remove TESTING ONLY
      ;IF DEBUG THEN BORDER 0
      PROC updateLoop(): ; update logic and render
      ;IF DEBUG THEN BORDER 2
    REPEAT UNTIL %P(0)=0 OR (t=0): ; until zero lives
    IF %t=0 THEN PROC nextLevel(LEVEL+1): ELSE PROC gameOver(): PROC initNewGame()
  REPEAT UNTIL 0: ; repeat forever
ENDPROC
;
; start main game loop - we do only one thing at a time in the main loop
DEFPROC updateLoop()
  PROC updatePlayer(%8)
  LET %b=1: ; baddie loop
  REPEAT
    %i=%b*6: ; 6 props (easy to mess this up!)
    IF % SPRITE CONTINUE b < 2 THEN PROC updateBaddie()
    LET %b=%b+1
  REPEAT UNTIL %b=(c+1)
  IF INKEY$ ="h" THEN PROC pauseGame()
  SPRITE MOVE INT  : ;without INT itseems TO RUN atinybitsmoother ON tombintersections
  IF %m <> -1 THEN DRIVER 49,2,%m:%m=%-1: ; play the activated sound effect
  ;PROC dT() TO %f: PRINT AT 0,0;%c;"@";%f;" ": ; f big = bad, small = good
ENDPROC
;
; %z = speed of player
DEFPROC updatePlayer(%z)
  PROC treadMark(): ; put treadmarks on the place we're about to move away from

  LET %j= IN 31: ; check the joystick and then keys

  ; help the player when turning corners - but only with the joystick, not the keyboard
  IF %j THEN IF %y MOD 40 OR (y > $ff) THEN IF %(j&@0011)=j THEN %j=%j+q: ; add the y direction
  IF %j THEN IF %x MOD 48 THEN IF %(j&@1100)=j THEN %j=%j+q: ; add the x direction

  ; NOTE: these shifts aren't always needed, but it makes the code consistent
  IF %( IN $fbfe >> 0&1^1) THEN LET %j=%j+@1000: ; Q
  IF %( IN $fdfe >> 0&1^1) THEN LET %j=%j+@0100: ; A
  IF %( IN $dffe >> 1&1^1) THEN LET %j=%j+@0010: ; O
  IF %( IN $dffe >> 0&1^1) THEN LET %j=%j+@0001: ; P

  ; NOTE I no longer do an early exit - this keeps the game speed constant, otherwise the baddies speed up
  ; IF %j&$0f=0 THEN LET %P=%$ffff: ENDPROC : ; play isn't moving, early exit

  ; the last direction is stored in the up/down/left/right routines

  ; If I can't move on the x plane, check y
  IF %x MOD 48 THEN : ELSE : IF %j&@0100 THEN PROC down(%z): ELSE IF %y > 0 AND (j&@1000) THEN PROC up(%z)

  PROC checkTomb(): ; %P = $ffff if they haven't moved

  IF %y MOD 40 OR (y > $ff) THEN : ELSE : IF %j&@0010 THEN PROC left(%z): ELSE IF %j&@0001 THEN PROC right(%z)

  ; note that %x > $ff means the integer has gone from 0, to -1, but it's unsigned
  ; so it'll be up in the 65K range, so this check against 255 is good enough
  IF %x > $ff THEN : LET %x=0: ELSE IF %x > 240 THEN : LET %x=240

  IF %t=1 THEN IF %j&@1000 AND (y=0) AND (x=96) THEN PROC up(%z):%t=0:%m=2: SPRITE 64,%x+32,%y+48,%s,%d: ENDPROC
  IF %y=$FFF0 OR (y=$FFF8) THEN : ELSE : IF %y > $ff THEN : LET %y=0: ELSE IF %y > 160 THEN : LET %y=160

  ; render
  SPRITE 64,%x+32,%y+48,%s,%d

  ; check the 2nd tomb _after_ sprite render to help smooth out the movement
  PROC checkTomb()

  ; check if we're bumping into a baddie
  %i=% SPRITE OVER (64,1 TO c)
  IF %i=0 THEN ENDPROC
  SPRITE %i,,,,0
  %i=%i*6
  IF %A[i+4]=0 THEN ENDPROC : ; ignore hidden zombies/inactive baddies
  %A[i+4]=0
  %A[i+5]=0
  IF %P(3)=0 THEN %m=5: PROC takeLife(%1): ELSE %P(3)=0: PROC takeLife(%0): PROC printScore(10):%m=6
ENDPROC
;
DEFPROC checkTomb()
  ; IIRC the PAUSE 1 is to attempt to match the timing if the player _had_ openned a tomb
  IF %(x MOD 48) OR (y MOD 40) THEN PAUSE 1: ENDPROC : ; only run on corners
  LET %i=%(6*(y/40))+(x/48): ; x/y as aisle index (6 aisles for 5 rows of tombs)

  %e=%P(4): ; shorthand help - saves looking up all the time

  IF %i=e THEN PAUSE 1: ENDPROC : ; we were just there (%e is last position)
  IF %e=$ffff THEN %P(4)=%i: PAUSE 1: ENDPROC

  %f=%i-e: ; f is forward +1 or backward -1
  %k=% ABS SGN {f}=1: ; k tracks the axis, +1 for X, 0 for Y

  ; important: %g is assigned here and used within getXTombs and getYTombs
  IF % SGN {f < 0} THEN %g=%e: ELSE %g=%i

  IF %k THEN PROC getXTombs() TO %g,%h: ELSE PROC getYTombs() TO %g,%h

  ; note that index 20 is out of bounds and assigns to the junk element
  ;PRINT AT 21,0;"g:";%g;",h:";%h;"  "
  IF %g < 20 THEN PROC crackEdge(%k,%g,%T(g),1,%@11011111,%@10111111)
  IF %h < 20 THEN PROC crackEdge(%k,%h,%T(h),0,%@01111111,%@11101111)

  %P(4)=%f+e: ; save the last position (reverting from %f we lost %i)
ENDPROC
;
; getXTombs: get tombs above and below of player
DEFPROC getXTombs()
  ; %g from checkTomb
  %h=%1+(g/6)
  %i=%g-h
ENDPROC =%i-5,%i
;
; getYTombs: get tombs on the left and right of player
DEFPROC getYTombs()
  ;%g is from checkTomb

  ; this uses special logic for the left and right edge of the grid,
  ; otherwise when you complete tomb 4 (x:4, y:0) then it wrongly
  ; applies a completed edge to 5 (x:0, y:1). The logic below fixes
  ; that - and returns '21' for a non existant/out of scope tomb
  %v=%(g+1) MOD 6
  IF %v > 1 THEN %i=%g-6-(g/6): ENDPROC =%i,%i+1: ; inner grid
  IF %v=1 THEN %i=%g-6-(g/6): ENDPROC =21,%i+1: ; completed on right edge
ENDPROC =%g-6-(g/6),21: ; case 0 = completed on left edge
;
DEFPROC crackEdge(%k,%i,%j,%o,%a,%b)
  ; cache the curent value, and if it doesn't change, nothing to do / endproc
  IF %j&8=8 THEN ENDPROC

  %u=%2+((i MOD 5)*6): ; map X to the x coord in tile offset
  %v=%4+((i/5)*5): ; same with Y

  ; bitwise op below is $current wall & (0xF0 + wall, 1 top, 2 right, 4 bottom, 8 left)
  ; importantly this leaves the first 4 bits untouched (Least Significant Nibble) meaning: @00001111
  IF %k THEN %T(i)=%T(i)&a: ELSE %T(i)=%T(i)&b
  IF %T(i)=j THEN ENDPROC

  ; print the cracked tile
  IF %k THEN TILE 4,1 AT 0,%24+o TO %u,%v+(o*2): ELSE TILE 1,3 AT %0+o,%21 TO %u+(o*3),%v

  %j=%T(i)

  ; only continue if the tomb is fully open
  IF %j&$f8 <> 0 THEN ENDPROC

  ; open tomb (ie. slightly different colour)
  TILE 4,3 AT 0,3 TO %u,%v

  IF %m=4 THEN : ELSE : IF %j=0 OR (j=4) THEN %m=0: ELSE IF %j > 2 THEN %m=1: ELSE %m=4:

  TILE 4,3 AT 0,%(3*j)+3 TO %u,%v

  ; if we revealed a baddie, bring them to life, and kick them off
  IF %j=4 THEN PROC revealBaddie()

  ; archaeologist(1), key(2), amulet(3), baddie(4) or treasure(5)
  %w=1: ; 1 point for unlocking a tomb either way
  IF %j=1 THEN %t=%t-1:%w=25: SPRITE %55+ INT {LEVEL}+1,,,52,1: ELSE IF %j=2 THEN %w=25:%t=%t-1: ELSE IF %j=3 THEN %P(3)=%1: PROC takeLife(%0): ELSE IF %j=5 THEN %w=5

  %T(i)=%j+8: ; prevent the tomb from being reopened

  PROC printScore(%w)
ENDPROC
;
; should only ever be called from crackEdge - a separate routine for ledgability
DEFPROC revealBaddie()
  %A[6+4]=%$ff
  %A[6+3]=3
  SPRITE 1,,,%A[6+5]-4,1
  SPRITE CONTINUE 1, STOP ,%A[7] TO %A[7]+16 STEP 1 RUN ,%A[6+5]-4 TO %A[6+5]-1, BIN 10,1,20
ENDPROC
;
;
; leave tread marks
DEFPROC treadMark(): ;down=0,up=2,left=4,right=6
  IF %P=$ffff THEN ENDPROC : ; didn't move
  IF %P > 3 THEN %i=%(x >> 3) MOD 2: ELSE %i=%(y >> 3) MOD 2: ; if left +1, right = -1
  ;
  %v=%(y >> 3)+2
  IF %v > 8000 THEN %v=%v MOD 8192: ; handle when player is in start position

  ; IF %P=0 THEN TILE 2,1 AT 0,%26+i TO %x >> 3,%v
  ; IF %P=2 THEN TILE 2,1 AT 2,%26+i TO %x >> 3,%v+1
  ; IF %P=4 THEN TILE 1,2 AT %0+i,28 TO %x >> 3+1,%v
  ; IF %P=6 THEN TILE 1,2 AT %2+i,28 TO %x >> 3,%v
  ; The four above lines can be refactored into a single line below
  IF %P < 3 THEN TILE 2,1 AT %P,%26+i TO %x >> 3,%v+(P >> 1): ELSE TILE 1,2 AT %P-4+i,28 TO %x >> 3+(P MOD 3),%v

  %P=%$ffff: ; now we're not moving
ENDPROC
;
; handle baddies
;
DEFPROC updateBaddie()
  ; if this baddie is dead, fast exit
  IF %A[i+4]=0 THEN ENDPROC

  %f=% SPRITE AT (b,0): ; x
  %g=% SPRITE AT (b,1): ; y

  ; select a random direction 0-3 is valid, but if we have a random value higher
  ; then decide whether the baddie should chase the goodie, or keep going in the
  ; current direction
  %j=% RND 12
  IF %j > 3 THEN %j=%A[i+3]

  ; if they're on the edge of the map, don't let them walk off
  IF %g=208 THEN IF %j=0 THEN %j=1
  IF %g=48 THEN IF %j=1 THEN %j=0
  IF %f=272 THEN IF %j=2 THEN %j=3
  IF %f=32 THEN IF %j=3 THEN %j=2

  ; save their direction
  %A[i+3]=%j

  ; FIXME what does this do?
  %A[(i*j)+2]=0

  ; this handles an edge case whereby the baddie is being revealed from hiding
  ; and they're not on the right Y plane, so the distance to the next intersection is adjusted
  %v=%48
;   IF %(f-32) MOD 48=0 THEN : ELSE %v=%32: IF %j < 2 THEN %j=%j+2: ELSE : PRINT AT 21,0;"done"
  IF %(f-32) MOD 48 <> 0 THEN PROC updateBaddieAdjust()

  ; Note: I don't make use of the sprite mirror flag, instead I'm storing all the permutations of the sprite
  ; because I have room, and it means that I don't need an IF and subsequent SPRITE statement, i.e. the
  ; fastest code is no code.
  %e=%A[i+5]
  IF %j=0 THEN SPRITE CONTINUE %b, STOP ,%g TO %g+40 STEP %z RUN ,%e-4 TO %e-3, BIN 10,0,0: ENDPROC : ; down
  IF %j=1 THEN SPRITE CONTINUE %b, STOP ,%g-40 TO %g STEP % SGN {-z} RUN ,%e-2 TO %e-1, BIN 10,0,0: ENDPROC : ; up
  IF %j=2 THEN SPRITE CONTINUE %b,%f TO %f+v STEP %z RUN , STOP ,%e TO %e+1, BIN 10,0,0: ENDPROC : ; right
  IF %j=3 THEN SPRITE CONTINUE %b,%f-v TO %f STEP % SGN {-z} RUN , STOP ,%e+2 TO %e+3, BIN 10,0,0: ENDPROC : ; left
ENDPROC
;
DEFPROC updateBaddieAdjust()
  %v=%32
  IF %j < 2 THEN %j=%j+2

  ; if the baddie on the far right edge, the force them to go 16
  IF %f=256 THEN IF %j=2 THEN %v=16
ENDPROC
;
; modifies: j, i, k
DEFPROC takeLife(%a)
  LOCAL %i: LOCAL %j: LOCAL %k
  IF %a THEN PROC setBorder(%$1c0)

  %j=%P(0)-a

  IF %j=0 THEN %m=3: ; REALLY dead sound effect

  %P(0)=%j

  ; print hearts
  FOR %i=1 TO %j
    SPRITE %40+i,%16,%32+(i*14),54,1
  NEXT %i

  ; now print empty
  %k=%7-( INT {DIFFICULTY}*2)
  FOR %i=%j+1 TO %k
    SPRITE %40+i,%16,%32+(i*14),55,1
  NEXT %i
  ; note that %i increments beyond the max value
  SPRITE %46,%14,%36+(i*14),56,%P(3)

  PAUSE 5
  IF %a THEN PROC setBorder(%$168-C( INT {LEVEL}))
ENDPROC
;
DEFPROC up(%z): ; move up
  %q=8
  %P=2: ; I'm fairly certain that q and P do pretty much the same thing
  %y=%y-z
  %d=%d^@1000
  %s=50
ENDPROC
;
DEFPROC down(%z): ; move down
  IF %y < 160 THEN : ELSE IF %y >= $FFF0 THEN : ELSE ENDPROC
  %q=4
  %P=0
  %y=%y+z
  %d=%d^@1000
  %s=51
ENDPROC
;
DEFPROC left(%z): ; move left
  %q=2
  %P=4
  %x=%x-z
  %d=%@1001
  %s=%s+1: IF %s > 49 THEN %s=48
ENDPROC
;
DEFPROC right(%z): ; move right
  %q=1
  %P=6
  %x=%x+z
  %d=%@0001
  %s=%s+1: IF %s > 49 THEN %s=48
ENDPROC
;
; %w = score number
DEFPROC pad(%w)
  IF %w < 10 THEN ENDPROC ="000"
  IF %w < 100 THEN ENDPROC ="00"
  IF %w < 1000 THEN ENDPROC ="0"
ENDPROC =""
;
; %i = value to *add* to score
DEFPROC printScore(%i)

  %P(1)=%P(1)+(i*P(2))
  %w=%P(1)

  IF %w > INT {H(1)} THEN H(1)=%w: LAYER PALETTE 0,2,%$1c5:

  w$=""
  IF %w < 1001 THEN PROC pad(%w) TO w$
  PRINT AT 0,6;w$;%w

  PRINT AT 0,27;H(1)
ENDPROC
;
; init functions
;
DEFPROC initSprites()
  SPRITE CLEAR : LAYER 2,1: SPRITE BORDER 1: SPRITE PRINT 1
  BANK 19 CLEAR
  BANK 23 COPY TO 19: ; reset the map
  TILE DIM 19,0,32,8: ; using tile bank 19, offset 0, tile 32 wide, tile size 8
  TILE 32,24: ; print tile for 14 tile cols by 12 tile rows
  TILE DIM 27,0,4,8: ; swap to our tomb tile set
  SPRITE STOP : ; switch to batching (though pretty sure this isn't required)
ENDPROC
;
; %n = 512 colour index
DEFPROC setBorder(%n)
  LAYER 1,0: PALETTE DIM 9
  BANK 28 DPOKE %(512+32),%((n&1) << 8)+(n >> 1): ; poke 16bit little endian next colour
  BORDER 0
  LAYER PALETTE 0 BANK 28,512
  LAYER 2,1: ; re-select our original layer
  PAPER 0: INK 2: ; note that ink 2 is changed on the fly
ENDPROC
;
DEFPROC pauseGame()
  ; note that this tiles with a black with priority set, so it will sit above sprites
  LAYER 2,1

  ; backup the screen
  BANK 10 COPY TO 30

  ; stop the music
  DRIVER 50,4

  ; paint it black
  TILE DIM 26,0,16,8
  TILE 16,3 AT 0,2 TO 8,8
  TILE 16,3 AT 0,2 TO 8,11

  %i=13
  TILE 1,1 AT 10,0 TO %i+0,10: ;  P
  TILE 1,1 AT 11,0 TO %i+1,10: ; A
  TILE 1,1 AT 12,0 TO %i+2,10: ; U
  TILE 1,1 AT 13,0 TO %i+3,10: ; S
  TILE 1,1 AT 14,0 TO %i+4,10: ; E
  TILE 1,1 AT 15,0 TO %i+5,10: ; D

  PROC pressAnyKey()

  ; resume music if it wass on
  IF MUSIC THEN DRIVER 50,2: DRIVER 50,3

  ; restore the screen
  BANK 30 COPY TO 10

  ; put original tiles back
  TILE DIM 27,0,4,8
ENDPROC
;
DEFPROC gameOver()
  PAPER 0: INK 255

  ; note that this tiles with a black with priority set, so it will sit above sprites
  LAYER 2,1
  TILE DIM 26,0,16,8
  TILE 16,3 AT 0,2 TO 8,9
  TILE 16,3 AT 0,2 TO 8,12
  TILE 16,3 AT 0,2 TO 8,15

  LET %j=%P(1)= INT {H(1)}

  IF NOT MUSIC THEN : ELSE IF %j THEN  DRIVER 50,1,0,25: ELSE DRIVER 50,1,0,21
  IF MUSIC THEN DRIVER 50,2: DRIVER 50,3

  FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  TILE 1,1 AT 0,0 TO 8,12: FOR %i=%0 TO %20: PAUSE 1: NEXT %i: ;  G
  TILE 1,1 AT 1,0 TO 10,12: FOR %i=%0 TO %20: PAUSE 1: NEXT %i: ; A
  TILE 1,1 AT 2,0 TO 12,12: FOR %i=%0 TO %20: PAUSE 1: NEXT %i: ; M
  TILE 1,1 AT 3,0 TO 14,12: FOR %i=%0 TO %20: PAUSE 1: NEXT %i: ; E
  TILE 1,1 AT 4,0 TO 17,12: FOR %i=%0 TO %20: PAUSE 1: NEXT %i: ; O
  TILE 1,1 AT 5,0 TO 19,12: FOR %i=%0 TO %20: PAUSE 1: NEXT %i: ; V
  TILE 1,1 AT 6,0 TO 21,12: FOR %i=%0 TO %20: PAUSE 1: NEXT %i: ; E
  TILE 1,1 AT 7,0 TO 23,12: FOR %i=%0 TO %20: PAUSE 1: NEXT %i: ; R

  IF %j THEN TILE 9,1 AT 7,1 TO 11,14: ELSE TILE 7,1 AT 0,1 TO 12,14: ; "you ded" / "hi score"
  FOR %i=%0 TO %20: PAUSE 1: NEXT %i

  REPEAT : REPEAT UNTIL INKEY$ =""
  REPEAT : REPEAT UNTIL INKEY$ <> "" OR ( IN 31=16)
  PROC freeze(): ; not quite ideal, but it'll hopefully make the transition to main screen better
  PROC saveHighScore()
  REPEAT : REPEAT UNTIL INKEY$ =""

  SPRITE CLEAR
ENDPROC
;
DEFPROC resetMusic()
  DRIVER 50,1,0,20: ; reset to the main music
  DRIVER 50,2
  IF MUSIC THEN DRIVER 50,3
ENDPROC
;
DEFPROC saveHighScore()
  IF %P(1) > H(1) THEN H(1)=%P(1): SAVE "assets/scores.bin" DATA H()
ENDPROC
;
; initBaddies: %A=Array[[x,y,spr,angle(0: x, 1: y),direction(0: backward, 1: forward),alive]] (allowing for more than 10 baddies)
; note: i*j = j properties per baddie
DEFPROC initBaddies()
  LET %j=6: ;n props
  FOR %i=1 TO %c
    LET %A[i*j]=%( RND 6)*48: ; 0 = x
    LET %A[(i*j)+1]=%40+( RND 4*40): ; 1 = y - baddies start on bottom 3 rungs
    LET %A[(i*j)+2]=0: ; 2 = delay (used to be SPRITE)
    LET %A[(i*j)+3]=% RND 4: ;3 = qaop/direction
    ; if we're on the last baddie, then we'll set them to dead, but they'll come to life later
    IF %i=1 THEN %A[(i*j)+4]=%$0: ELSE %A[(i*j)+4]=%$ff: ; 4 = alive (note to self: I changed this to 1 and baddie walked backwards)
    LET %A[(i*j)+5]=%44-(8*(c-i)): ; 5 = sprite offset (for baddie type)
    SPRITE %i,%A[i*j]+32,%A[(i*j)+1]+48,%A[(i*j)+5],%1&A[(i*j)+4]
  NEXT %i
ENDPROC
;
DEFPROC initTombs()
  FOR %i=0 TO 20: ; note that index 20 is used for dumping invalid/out of bounds
    LET %T(i)=%$f0: ; this is 11110000 - each edge is the high nibble and set as closed/waiting to be masked later
  NEXT %i

  PROC pickRandom()

;    %W(3)=%4: ; use to force hidden baddie position

  ; generates: scroll (0), archaeologist (1), key (2), hidden mummy/baddie (3)
  FOR %i=%0 TO %3
    %T(W(i))=%$f1+i
  NEXT %i
;   PRINT AT 22,0;"Hidden @ ";%W(3)

  ; hides the baddie in a tomb
  %A[6]=%(W(3) MOD 5)*48+32+32
  %A[7]=%(W(3)/5)*40+24+48
  SPRITE 1,%A[6],%A[7],,,
  ;
  ; treasures x 5
  FOR %i=%4 TO %8
    %T(W(i))=%$f5
  NEXT %i
ENDPROC
;
DEFPROC pickRandom()
  LOCAL %n: LOCAL %t: LOCAL %v: LOCAL %i

  %v=20: ; select from 0-20 (excluding 20)
  %i=0
  ; init the 0-N array
  REPEAT
    %R(i)=%i
    %i=%i+1
  REPEAT UNTIL %i=v
  ; then go back downwards for P values
  REPEAT
    %t=% RND i
    %W(v-i)=%R(t): ; W is our global (winning positions)
    %i=%i-1
    %R(t)=%R(i)
  REPEAT UNTIL %i=(v-9)
  ; pickings are in global array W
ENDPROC
;
DEFPROC loadAssets()
  LAYER CLEAR
  LAYER 2,1
  LAYER BANK 9,12
  PAPER 0
  CLS
  PROC freeze()
  PAPER 252: INK 0: BORDER 0:
  SPRITE CLEAR
  ; allows for stop and start when music is running still
  ON ERROR CONTINUE : DRIVER 50,4: ON ERROR
  ON ERROR CONTINUE :.uninstall "assets/nextdaw.drv" : ON ERROR
  .install "assets/nextdaw.drv"
  ON ERROR CONTINUE :.uninstall "assets/ayfx.drv" : ON ERROR
  .install "assets/ayfx.drv"

  ; note: I'm being a bit lavish with my banks here, but I could pretty easily
  ; upgrade the .map files to exist in a single file and single bank, just use
  ; offsets (same goes with .pal, .adb and .bin)
  LOAD "assets/music.ndr" BANK 20
  LOAD "assets/gameover.ndr" BANK 21
  LOAD "assets/hiscore.ndr" BANK 25
  LOAD "assets/m-sprites.spr" BANK 22: SPRITE BANK 22
  LOAD "assets/mummy.map" BANK 23: ;load tile map created at https://zx.remysharp.com/sprites/
  LOAD "assets/m-tiles.spr" BANK 24: TILE BANK 24: ; load spritesheet for tiles
  LOAD "assets/gameover.map" BANK 26
  LOAD "assets/tombs.map" BANK 27
  LOAD "assets/mummy.pal" BANK 28
  LOAD "assets/mummy.afb" BANK 29: ; sound effects
  LOAD "assets/font.bin" CODE 64000
  ; bank 30 is used for temp layer 2,1 data
  LOAD "assets/banner1.bin" BANK 31: ; header for non-game screens
  LOAD "assets/banner2.bin" BANK 32: ; header for non-game screens
  LOAD "assets/banner3.bin" BANK 33: ; header for non-game screens

  ; this isn't particularly required, but I've got the space in memory
  ; and it means there's no pause in the music when the screens are loading
  LOAD "assets/story.bin" BANK 34
  LOAD "assets/controls.bin" BANK 35
  LOAD "assets/credits.bin" BANK 36
  LOAD "assets/discover.bin" BANK 37

  LOAD "assets/scores.bin" DATA H()
ENDPROC
;
DEFPROC initOnce()
  PROC loadAssets(): ; separate load allows for future single tape loader

  %m=%-1
  PLAYING=0
  DIFFICULTY=2
  SPEED=2

  %S(1)=%4
  %S(2)=%8
  %S(3)=%12

  %C(1)=%0
  %C(2)=%16
  %C(3)=%236
  %C(4)=%82
  %C(5)=%128

  MUSIC= NOT DEBUG

  ; init the sound effects
  DRIVER 49,1,29

  ; font
  DPOKE 23606,63744: ; 64000-256
  LAYER 2,1
  PRINT CHR$ 2: ; trigger the font to be loaded
  ; reduce the font into 7x8 (bit more space to write)
  ;PRINT CHR$ 30; CHR$ 7; CHR$ 31; CHR$ 7

  ; colour palette
  PALETTE DIM 9
  LAYER PALETTE 0 BANK 28,0
  LAYER PALETTE 0

  POKE 23658,0: ; turn off CAPS LOCK (for menu items)
ENDPROC
;
DEFPROC initGameVars()
  LET %x=%96
  LET %y=%-16
  LET %s=%51: ; s=sprite
  LET %q=%0: ; last direct
  LET %d=%1: ; direction & speed
  LET %P=%0: ; %P = last player position
  LET %a=%$ffff
  LET %t=%3
ENDPROC
;
DEFPROC youWin()
  LEVEL=1
  PROC setBorder(%0)
  SPEED=3: ; GO FAST!
  %z=%S(3)

  ; update the score multiple
  %i=% INT {SPEED}
  %j=% INT {DIFFICULTY}
  %P(2)=%(j-1)+i

  SPRITE PRINT 0
  PAPER 252: INK 0: BORDER 0
  LOAD "assets/youdidit.sl2" LAYER

  LET %y=7

  PROC narrowFont()

  PRINT AT %y+2,1;"You saved all five of the "
  PRINT AT %y+3,1;"archaeologists. They're safe back"
  PRINT AT %y+4,1;"home drinking tea and dunking"
  PRINT AT %y+5,1;"biscuits. Great work!"

  PRINT AT %y+8,1;"But...a hero's work is never done."
  PRINT AT %y+9,1;"More archaeologists have gone"
  PRINT AT %y+10,1;"walkies, and they need your help."
  PRINT AT %y+12,1;"Will you survive the challenge?"

  PROC resetFont()
  PAPER 0: INK 252
  PRINT AT %y+14,13;"Onward adventurer!"
  PAPER 252: INK 0

  PROC pressAnyKey()
ENDPROC
;
DEFPROC freeze()
  ; point Layer 2 to the shadow layer
  LAYER BANK 12,9
ENDPROC
;
DEFPROC defrost()
  LAYER BANK 9,9
ENDPROC
;
DEFPROC initNewGame()
  PROC welcome()
  PROC freeze()
  PROC initPlayerState()
  ; define player and game state
  %z=%S( INT {SPEED}): ; baddie speed

  PLAYING=1

  PROC resetFont()

  PROC nextLevel(1)
ENDPROC
;
DEFPROC initPlayerState()
  %P(0)=%7-( INT {DIFFICULTY}*2): ; lives
  %P(1)=%0: ; score
  %i=% INT {SPEED}
  %j=% INT {DIFFICULTY}
  %P(2)=%(j-1)+i: ; score multiple
ENDPROC
;
DEFPROC resetPlayerState()
  %P(3)=%0: ; has scroll / can kill baddie
  %P(4)=%$ffff: ; player last corner
ENDPROC
;
DEFPROC nextLevel(l)
  RANDOMIZE 0
  LEVEL=l
  IF LEVEL=6 THEN PROC youWin()

  %j=% INT {LEVEL}

  %c=%j+1: ; baddies increase with each level

  ; 0x150, 0x1f8, 0x1e8, 0x168
  ; offset values:
  ; yellow (0), orange (16), purple (236), party pink (82), green (128)
  LAYER 2,1
  %i=%C(j): ;%i=%82 : ; used to test colours
  LAYER PALETTE 0,33,%$150-i
  LAYER PALETTE 0,34,%$1f8-i
  LAYER PALETTE 0,35,%$1e8-i
  LAYER PALETTE 0,36,%$168-i

  PAPER 0: INK 2: ; note that ink 2 is changed on the fly
  PROC resetPlayerState()
  PROC initSprites()
  IF %P(1)=0 THEN LAYER PALETTE 0,2,%$1ff
  PROC initBaddies()
  PROC initTombs()
  PROC initGameVars()
  PROC treadMark(): ; depends on player position
  PROC takeLife(%0): ; renders the lives

  PROC printScore(% INT {(LEVEL-1)*50})


  ; show how many archaeologist's are left to save
  FOR %i=2 TO LEVEL
    SPRITE %55+i,%290,%14+(i*18),52,1
  NEXT %i
  FOR %i=LEVEL+1 TO 6
    SPRITE %55+i,%290,%14+(i*18),53,1
  NEXT %i

  ; wait for a key up
  REPEAT : REPEAT UNTIL INKEY$ =""
  PROC setBorder(%$168-C( INT {LEVEL}))
  PROC defrost()
ENDPROC
;
DEFPROC dT()
  LET %g=% PEEK 23672
  LET %f=%g-n
  IF %g < n THEN LET %f=%f+256
  LET %n=%g
ENDPROC =%f
;
DEFPROC optionsScreen()
  PROC header(0)

  LET %y=9
  DIFFICULTY=0
  %z=0

  PRINT AT %y+1,5;"Speed of guardians ?"
  PRINT AT %y+3,5;"[1] I'm a kid, be gentle"
  PRINT AT %y+5,5;"[2] Regular speed"
  PRINT AT %y+7,5;"[3] BRING IT ON!!!"
  PAUSE 100
  REPEAT
    SPRITE MOVE INT
    LET %j=% INT { CODE INKEY$ }-$30
    IF %j < 4 THEN %z=%j
  REPEAT UNTIL %z <> 0
  PRINT AT %y+(z*2+1),5; INVERSE 1;" ";%z;" "
  IF %z=1 THEN PRINT AT %y+10,5;"Gentle it shall be"
  IF %z=2 THEN PRINT AT %y+10,5;"Not feeling brave, eh?"
  IF %z=3 THEN PRINT AT %y+10,5;"Nutter. You're on."
  SPEED=%z: ; maps 1 to 5, 2 to 3, 3 to 1
  %z=%S(z)

  REPEAT : REPEAT UNTIL INKEY$ ="": ; wait until the key is up again
  FOR %i=%0 TO %50: SPRITE MOVE INT : NEXT %i

  PROC header(0)

  PRINT AT %y+1,5;"Difficulty level ?"

  PRINT AT %y+3,5;"[1] I need ALL the help"
  PRINT AT %y+5,5;"[2] I'll manage fine"
  PRINT AT %y+7,5;"[3] DEATHWISH"

  REPEAT
    SPRITE MOVE INT
    LET %j=% INT { CODE INKEY$ }-$30
    IF %j < 4 THEN DIFFICULTY=%j: ; maps 1 to 3, 2 to 2, 3 to 1
  REPEAT UNTIL DIFFICULTY <> 0
  ;PRINT AT %y+1,30;DIFFICULTY
  PRINT AT %y+(j*2+1),5; INVERSE 1;" ";%j;" "
  IF %j=1 THEN PRINT AT %y+10,5;"You got it!"
  IF %j=2 THEN PRINT AT %y+10,5;"The guardians beg to differ"
  IF %j=3 THEN PRINT AT %y+10,5;"RAAAAAAAAA!!!"

  REPEAT : REPEAT UNTIL INKEY$ ="": ; wait until the key is up again
  FOR %i=%0 TO %50: SPRITE MOVE INT : NEXT %i

  PROC header(0)

  MUSIC=2
  PRINT AT %y+1,5;"Background music ?"
  PRINT AT %y+3,5;"[y] IT ROCKS \m/"
  PRINT AT %y+5,5;"[n] I prefer to work"
  PRINT AT %y+6,5;"    in silence"
  REPEAT
    SPRITE MOVE INT
    c$= INKEY$
    IF c$="y" THEN MUSIC=1: PRINT AT %y+3,5; INVERSE 1;" y ": PRINT AT %y+10,3;"It's pretty banging isn't it?"
    IF c$="n" THEN MUSIC=0: PRINT AT %y+5,5; INVERSE 1;" n ": PRINT AT %y+10,5;"Okay, shushing now"
  REPEAT UNTIL MUSIC < 2

  IF MUSIC=0 THEN DRIVER 50,4: ELSE DRIVER 50,2: DRIVER 50,3

  REPEAT : REPEAT UNTIL INKEY$ ="": ; wait until the key is up again
  FOR %i=%0 TO %50: SPRITE MOVE INT : NEXT %i

ENDPROC
;
DEFPROC narrowFont()
  PRINT AT 0,0; CHR$ 30; CHR$ 7; CHR$ 31; CHR$ 7
ENDPROC
;
DEFPROC resetFont()
  PRINT AT 0,0; CHR$ 30; CHR$ 8; CHR$ 31; CHR$ 8
ENDPROC
;
DEFPROC creditScreen()
  PROC header(36)

  LET %y=9

  PRINT AT %y+1,3;"Written by Remy Sharp";
  PRINT AT %y+2,3;"https://remysharp.com / @rem"
  PRINT AT %y+4,3;"Guardians by Remy's kids"
  PRINT AT %y+6,3;"Music by Richard Faulkner"
  ; font: https://spectrumcomputing.co.uk/entry/25364/ZX-Spectrum/The_8bit_Font_Collection
  PRINT AT %y+8,3;"Font by Paul van der Laan"

  PAPER 0: INK 252
  PRINT AT %y+11,24;"Continue..."
  PAPER 252: INK 0

  PROC pressAnyKey()
ENDPROC
;
DEFPROC helpScreen()
  PROC header(34)

  LET %y=9
  ; 123456789012345678901234567890123456 (total column count: 36)

  PRINT AT %y,2;"In 1984 a party of archaeologists"
  PRINT AT %y+1,2;"went in search of lost treasures,"
  PRINT AT %y+2,2;"and yet they found themselves"
  PRINT AT %y+3,2;"simply crying OH MUMMY!"

  PRINT AT %y+5,2;"In the modern day, you're tasked"
  PRINT AT %y+6,2;"with the job of rescuing the"
  PRINT AT %y+7,2;"archaeologists from their failed"
  PRINT AT %y+8,2;"pyramid plundering."

  PAPER 0: INK 252
  PRINT AT %y+11,24;"Continue..."
  PAPER 252: INK 0

  PROC pressAnyKey()

  PROC header(34)

  LET %y=9

  PRINT AT %y,2;"You must navigate five catacombs,"
  PRINT AT %y+1,2;"avoiding the guardians, rescue"
  PRINT AT %y+2,2;"those muppets and bring them"
  PRINT AT %y+3,2;"back to Blighty."
  PRINT AT %y+5,2;"Surround the tombs to find the"
  PRINT AT %y+6,2;"archaeologist and key to escape"
  PRINT AT %y+7,2;"the way you came in. And remember:"
  PRINT AT %y+9,2;"DON'T GET CHOMPED!"

  PAPER 0: INK 252
  PRINT AT %y+11,24;"Continue..."
  PAPER 252: INK 0

  PROC pressAnyKey()

  LET %y=8

  PROC header(37)

  ; the tokens from tombs.map
  TILE DIM 27,24,4,8
  TILE 4,3 AT  0,0 TO 2,%y
  TILE 4,3 AT 12,0 TO 2,%y+3
  TILE 4,3 AT 24,0 TO 2,%y+6
  TILE 4,3 AT 48,0 TO 2,%y+9

  PRINT AT %y+1,6;"Rescue this dude"
  PRINT AT %y+4,6;"Key to escape the catacomb"
  PRINT AT %y+7,6;"Protects you from a guardian"
  PRINT AT %y+10,6;"Gems means hi-scores"

  PAPER 0: INK 252
  PRINT AT %y+12,24;"Continue..."
  PAPER 252: INK 0

  PROC pressAnyKey()

  LOAD "assets/baddies.sl2" LAYER

  %y=8

  PAPER 252: INK 0
  PRINT AT %y+1,7;"Lampshade"
  PRINT AT %y+5,7;"Spatula"
  PRINT AT %y+9,7;"Crazihare"

  PRINT AT %y+1,21;"Baddiebear"
  PRINT AT %y+5,21;"Springzoid"
  PRINT AT %y+9,21;"Tentackly"

  PAPER 0: INK 252
  PRINT AT %y+12,24;"Continue..."
  PAPER 252: INK 0

  PROC pressAnyKey()

  PROC header(35)

  LET %y=5

  PRINT AT %y+4,3;"Kempton joystick and keyboard";
  PRINT AT %y+6,3;"Q= up"
  PRINT AT %y+7,3;"A= down"
  PRINT AT %y+6,18;"O= left"
  PRINT AT %y+7,18;"P= right"
  PRINT AT %y+9,3;"H= halt / pause"

  PRINT AT %y+11,3;"Crack each side of the tomb"
  PRINT AT %y+12,3;"to reveal the contents."

  PAPER 0: INK 252
  PRINT AT %y+15,24;"Continue..."
  PAPER 252: INK 0

  PROC pressAnyKey()

  PROC creditScreen()

ENDPROC
;
; %i = BANK_ID
DEFPROC header(%i)
  PAPER 252: INK 0: BORDER 0
  ; basically loading an SL2 file without the layer bit (and thus no file i/o)
  IF %i=0 THEN %i=31
  BANK %i COPY TO 9
  BANK 32 COPY TO 10: ; landing screen 2/3
  BANK 33 COPY TO 11: ; landing screen 3/3
ENDPROC
;
DEFPROC playScreen()
  PROC header(0)

  LET %y=9

  ; make the font massive :)
  PRINT CHR$ 29; CHR$ 1

  PRINT AT %y,6;"Rescue the archaeologists"
  PRINT AT %y+2,8;"    Save the day!"
  PRINT AT %y+4,8;"   Don't get eaten"
  PRINT AT 0,0; CHR$ 29; CHR$ 0
  BANK 11 ERASE %$2400,%$1c00,0: ; last 4k is black

  PRINT AT %18,9; INK 180;"Can you beat ";H(1);"?"

  PRINT AT %21,0; PAPER 0; INK 252;"I-Instructions   O-Options    P-Play"

ENDPROC
;
DEFPROC welcome()
  IF DEBUG THEN ENDPROC : ; FIXME remove
  PROC setBorder(%0)
  PLAYING=0
  SPRITE CLEAR
  SPRITE BORDER 0
  SPRITE BANK 22
  TILE BANK 24
  SPRITE STOP : ; switch to batching (though pretty sure this isn't required)
  SPRITE PRINT 1

  LET %x=304: LET %y=208
  SPRITE 64,%x,%y,48,%@1001
  SPRITE 63,%x,%y,46,1

  SPRITE CONTINUE 64,0 TO %x STEP -8 RUN , STOP ,48 TO 49, BIN 0001000,3,200
  SPRITE CONTINUE 63,0 TO %x STEP -8 RUN , STOP ,46 TO 47, BIN 0001000,3,225

  CLS
  PROC narrowFont()
  PROC playScreen()

  PROC defrost()

  ; start the music when the screen appears
  PROC resetMusic()

  REPEAT
    c$= INKEY$
    IF c$="i" THEN PROC helpScreen(): PROC playScreen()
    IF c$="o" THEN PROC optionsScreen(): PROC playScreen()
    SPRITE MOVE INT
    c$= INKEY$
  REPEAT UNTIL c$="p" OR IN 31=16

  LAYER CLEAR

ENDPROC
;
DEFPROC pressAnyKey()
  REPEAT : SPRITE MOVE INT : REPEAT UNTIL INKEY$ =""
  REPEAT : SPRITE MOVE INT : REPEAT UNTIL INKEY$ <> "" OR ( IN 31=16)
  REPEAT : SPRITE MOVE INT : REPEAT UNTIL INKEY$ =""
ENDPROC
;
DEFPROC reportErr()
  ERROR TO err,lin,st
  e$= STR$ err

  ON ERROR CONTINUE : DRIVER 50,4: ON ERROR
  ON ERROR CONTINUE :.uninstall "assets/nextdaw.drv" : ON ERROR
  ON ERROR CONTINUE :.uninstall "assets/ayfx.drv" : ON ERROR

  LAYER 2,1
  PALETTE CLEAR
  LAYER CLEAR
  SPRITE CLEAR
  CLS
  BORDER 7: INK 0: PAPER 7
  SPRITE PRINT 0: ; turn off sprites
  PRINT CHR$ 30,
  PRINT "Error:";e$;", line:";lin;", statement:";st
  PROC waitForKeyClear()
ENDPROC
;
DEFPROC exit()
  ; use break to exit mid-game
  IF PLAYING THEN PROC initNewGame(): PROC mainLoop(): ENDPROC
  GO TO 9999
ENDPROC
;
#autoline
9999 REG 2,1: ; soft reset
