#program mummy
#autostart 10
#autoline 10
; Oh Mummy (clone), Remy Sharp 2020 / @rem
;
RUN AT 3: REM @ 28Mhz
;
; ************ TODO ***************
; - [ ] (bug) baddies are faster than player (rendering is simpler)
; - [ ] (req) Game over - Win state
; - [ ] (req) Hi-score(?)
; - [ ] (perf) Don't call new round of poke on each level
; - [ ] (feat) Crack effect on tomb edge
; - [ ] (feat) Change colours of tombs between each level
; - [ ] (feat) "Get outta there" / "now find the archaeologist" / "find that key!" marquee
; - [ ] (feat) When player tries to turn 1 step away from a turn, "help" them and jump over it
; - [ ] (feat) AI for baddie & dumb baddies
; - [ ] (feat) Improve background tile/walkway image
; - [~] Welcome screen / start game
; - [x] (bug) Fix the top left corner foot steps
; - [x] (perf) Can we make screen transitions faster (tried different methods, prob not)
; - [x] Fix tomb 9 affecting tomb 10
; - [x] Fix baddie reveal - and the direction they go
; - [x] Baddie revealed
; - [x] Score
; - [x] 10 treasure chests
; - [x] Open tomb effect (spr@8-11 + 12 transparency)
; - [x] Level up
; - [x] Graphics for prize tombs
; - [x] Possibly allow player in start position?
;
; ******** VARIABLE INDEX *********
;
; %a = player last corner, used for tomb calc - initilised to $FF
; %A[] = baddie array (allows for > 64 elements)
; %b = baddie index
; %c = baddie count
; %d = player sprite flags (mirror, etc)
; %n = delta time counter (only used during dev, but needs to be reserved)
; %l = player lives
; %P = player last position, used for tread marks - initilised to $FFFF
; %q = player last direction (whilst movement is engaged)
; %r = (flag) player has scroll and can kill a mummy
; %s = player sprite
; %T(21) = tomb array 0-19 with index 20 used for temp rendering, with 8bit flags (14 items contain data in the low bit)
; %t = items to find - defaults to 2
; %w = score
; %x = player x
; %y = player y
; %z = speed (for both baddie and player) - calculated based on DIFFICULTY
; --- non int vars ---
; DIFFICULTY(3) = how smart the baddies's are (currently not!)
; LEVEL(1) = current level
; SPEED(3) = how fast the baddies are
; PLAYING = bool like - whether we're in game or not (in menus)
;
; TMP VARIABLES
; i, j, k (but often shared) - then - e, f, g, h, m, o, q, u, v (unless documented, are disposable between DEFPROCS)
;
; BANK INDEX
;
; 19: tiles (copied from BANK 23)
; 20: music (mummy.ndr)
; 21: music player (nextdaw.drv)
; 22: main player and NPC sprites (m-sprites.spr)
; 23: tile map (used with BANK 19) (mummy.map)
; 24: tile data (sprites) (m-tiles.spr)
; 25: "oh mummy" layer 2 header (1/3 of layer 2) (banner.bin)
; 26: info screen tokens (tokens.map)
; 27: tomb tiles - extra graphics arranged in a useful layout
;
; **********************************
;
;PROC dT()
;PROC splash()

DEBUG=1
SPRITEON=1

ON ERROR PROC exit()
PROC initOnce()
PROC initNewGame()
PROC mainLoop()

; game loop - includes: render loop, lives check & game over
DEFPROC mainLoop()
  REPEAT
    REPEAT
      IF DEBUG THEN IF INKEY$ ="s" THEN SPRITEON= NOT SPRITEON: SPRITE PRINT SPRITEON
      ;IF DEBUG THEN PRINT AT %1,%0;"mem=";%65536- USR 7962;" ": ; memory available....
      IF DEBUG THEN IF INKEY$ ="t" THEN %t=0: ; FIXME remove TESTING ONLY
      PROC updateLoop(): ; update logic and render
    REPEAT UNTIL %l=0 OR (t=0): ; until zero lives
    IF %t=0 THEN PROC nextLevel(LEVEL): ELSE PROC gameOver(): PROC initNewGame()
  REPEAT UNTIL 0: ; repeat forever
ENDPROC
;
; start main game loop - we do only one thing at a time in the main loop
DEFPROC updateLoop()
  PROC updatePlayer(%8)
  LET %b=1: ; baddie loop
  REPEAT
    %i=%b*6: ; 6 props (easy to mess this up!)
    ;IF % SPRITE CONTINUE b < 2 THEN PROC updateBaddie()
    LET %b=%b+1
  REPEAT UNTIL %b=(c+1)
  SPRITE MOVE INT
  ;PROC dT() TO %f: PRINT AT 0,0;%c;"@";%f;" ": ; f big = bad, small = good
ENDPROC
;
DEFPROC updatePlayer(%z)
  PROC treadMark(): ; put treadmarks on the place we're about to move away from

  LET %j= IN 31: ; check the joystick and then keys

  ; NOTE: these shifts aren't always needed, but it makes the code consistent
  IF %( IN $fbfe >> 0&1^1) THEN LET %j=%j+@1000: ; Q
  IF %( IN $fdfe >> 0&1^1) THEN LET %j=%j+@0100: ; A
  IF %( IN $dffe >> 1&1^1) THEN LET %j=%j+@0010: ; O
  IF %( IN $dffe >> 0&1^1) THEN LET %j=%j+@0001: ; P

  ; NOTE I no longer do an early exit - this keeps the game speed constant, otherwise the baddies speed up
  ; IF %j&$0f=0 THEN LET %P=%$ffff: ENDPROC : ; play isn't moving, early exit

  ; if I can't move on x plane, check y
  IF %x MOD 48 THEN : ELSE : IF %j&@0100 THEN PROC down(%z): ELSE IF %y > 0 AND (j&@1000) THEN PROC up(%z)
  ; IF %P <> $ffff THEN
  PROC checkTomb(): ; %P = $ffff if they haven't moved

  IF %y MOD 40 OR (y > $ff) THEN : ELSE : IF %j&@0010 THEN PROC left(%z): ELSE IF %j&@0001 THEN PROC right(%z)

  ; note that %x > $ff means the integer has gone from 0, to -1, but it's unsigned
  ; so it'll be up in the 65K range, so this check against 255 is good enough
  IF %x > $ff THEN : LET %x=0: ELSE IF %x > 240 THEN : LET %x=240

  IF %t=1 THEN IF %j&@1000 AND (y=0) AND (x=96) THEN PROC up(%z):%t=0: SPRITE 64,%x+32,%y+48,%s,%d: ENDPROC
  IF %y=$FFF0 OR (y=$FFF8) THEN : ELSE : IF %y > $ff THEN : LET %y=0: ELSE IF %y > 160 THEN : LET %y=160

  ; IF %P <> $ffff THEN
  PROC checkTomb()

  SPRITE 64,%x+32,%y+48,%s,%d

  %i=% SPRITE OVER (64,1 TO c)
  IF %i=0 THEN ENDPROC
  SPRITE %i,,,,0
  %i=%i*6
  IF %A[i+4]=0 THEN ENDPROC
  %A[i+4]=0
  %A[i+5]=0
  IF %r=0 THEN PROC takeLife(): ELSE %r=0
ENDPROC
;
DEFPROC checkTomb()
  LOCAL %j
  ; IIRC the PAUSE 1 is to attempt to match the timing if the player _had_ openned a tomb
  IF %(x MOD 48) OR (y MOD 40) THEN PAUSE 1: ENDPROC : ; only run on corners
  LET %i=%(6*(y/40))+(x/48): ; x/y as aisle index (6 aisles for 5 rows of tombs)
  IF %i=a THEN PAUSE 1: ENDPROC : ; we were just there (%a is last position)
  IF %a=$ffff THEN %a=%i: PAUSE 1: ENDPROC

  %f=%i-a: ; f is forward +1 or backward -1
  %k=% ABS SGN {f}=1: ; k tracks the axis, +1 for X, 0 for Y

  ; important: %g is assigned here and used within getXTombs and getYTombs
  IF % SGN {f < 0} THEN %g=%a: ELSE %g=%i

  IF %k THEN PROC getXTombs() TO %g,%h: ELSE PROC getYTombs() TO %g,%h

  ; note that index 20 is out of bounds and assigns to the junk element
  IF %g > 20 THEN %g=20: ; ELSE PROC crackEdge(%k,%g,1)
  IF %h > 20 THEN %h=20: ; ELSE PROC crackEdge(%k,%h,0)
  ; bitwise op below is $current wall & (0xF0 + wall, 1 top, 2 right, 4 bottom, 8 left)
  ; importantly this leaves the first 4 bits untouched (Least Significant Nibble) meaning: @00001111
  %i=%T(g)
  %j=%T(h)
  IF %k THEN %T(g)=%T(g)&@11011111:%T(h)=%T(h)&@01111111: ELSE %T(g)=%T(g)&@10111111:%T(h)=%T(h)&@11101111

  ; only do the work if the tomb changed state
  IF %T(g) <> i AND (g < 20) THEN PROC crackEdge(%k,%g,1): IF %T(g)&$f8=0 THEN PROC openTomb(%g)
  IF %T(h) <> j AND (h < 20) THEN PROC crackEdge(%k,%h,0): IF %T(h)&$f8=0 THEN PROC openTomb(%h)

  ; IF %T(g)&$f8=0 THEN PROC openTomb(%g): ; (value & 0xf8)==0 = all the walls are covered, and bit 4 (0x08) is _not_ set - then open the tomb
  ; IF %T(h)&$f8=0 THEN PROC openTomb(%h)
  ;
  %a=%f+a: ; save the last position (reverting from %f we lost %i)
ENDPROC
;
DEFPROC crackEdge(%k,%i,%o)
  %u=%2+((i MOD 5)*6): ; x in tile offset
  %v=%4+((i/5)*5): ; y in tile offset

  IF %k THEN TILE 4,1 AT 0,%24+o TO %u,%v+(o*2): ELSE TILE 1,3 AT %0+o,%21 TO %u+(o*3),%v
ENDPROC
;
; getXTombs: get tombs above and below of player
DEFPROC getXTombs()
  ; %g from checkTomb
  %h=%1+(g/6)
  %i=%g-h
ENDPROC =%i-5,%i
;
; getYTombs: get tombs on the left and right of player
DEFPROC getYTombs()
  ;%g from checkTomb

  ; this uses special logic for the left and right edge of the grid,
  ; otherwise when you complete tomb 4 (x:4, y:0) then it wrongly
  ; applies a completed edge to 5 (x:0, y:1). The logic below fixes
  ; that - and returns '21' for a non existant/out of scope tomb
  %v=%(g+1) MOD 6
  IF %v > 1 THEN %i=%g-6-(g/6): ENDPROC =%i,%i+1: ; inner grid
  IF %v=1 THEN %i=%g-6-(g/6): ENDPROC =21,%i+1: ; completed on right edge
ENDPROC =%g-6-(g/6),21: ; case 0 = completed on left edge

;
DEFPROC openTomb(%i)
  LOCAL %j
  %j=%T(i)
  IF %i=20 THEN ENDPROC :
  IF %j&8=8 THEN ENDPROC : ; Tomb is open, exit FIXME is this always false?

  ; I can't remember why this line ends with 4+i*5/5, but I did work it out
  ; and when I just do %4+i the tile drawing messes up, where as this is fine...
  %u=%2+((i MOD 5)*6): ; x in tile offset
  %v=%4+((i/5)*5): ; y in tile offset

  ; open tomb (ie. slightly different colour)
  TILE 4,3 AT 0,3 TO %u,%v

  ; early exit
  IF %j=0 THEN %T(i)=%j+8: ENDPROC

  TILE 4,3 AT 0,%(3*j)+3 TO %u,%v

  ; archaeologist(1), key(2), amulet(3), baddie(4) or treasure(5)
  IF %j=1 THEN %t=%t-1:%w=%w+50: ELSE IF %j=2 THEN %t=%t-1: ELSE IF %j=3 THEN %r=%1: ELSE IF %j=5 THEN %w=%w+5

  ; if we revealed a baddie, bring them to life, and kick them off
  IF %j=4 THEN %A[6+4]=%$ff:%A[6+3]=3: SPRITE 1,,,%A[6+5]-4,1: SPRITE CONTINUE 1, STOP ,%A[7] TO %A[7]+16 STEP 1 RUN ,%A[6+5]-4 TO %A[6+5]-1, BIN 10,1,20

  %T(i)=%j+8: ; prevent the tomb from being reopened
  PROC printScore()
ENDPROC
;
; leave tread marks
DEFPROC treadMark(): ;down=0,up=2,left=4,right=6
  IF %P=$ffff THEN ENDPROC : ; didn't move
  IF %P > 3 THEN %i=%(x >> 3) MOD 2: ELSE %i=%(y >> 3) MOD 2: ; if left +1, right = -1
  ;
  %v=%(y >> 3)+2
  IF %v > 8000 THEN %v=%v MOD 8192: ; handle when player is in start position

  ; IF %P=0 THEN TILE 2,1 AT 0,%26+i TO %x >> 3,%v
  ; IF %P=2 THEN TILE 2,1 AT 2,%26+i TO %x >> 3,%v+1
  ; IF %P=4 THEN TILE 1,2 AT %0+i,28 TO %x >> 3+1,%v
  ; IF %P=6 THEN TILE 1,2 AT %2+i,28 TO %x >> 3,%v
  ; The four above lines can be refactored into a single line below
  IF %P < 3 THEN TILE 2,1 AT %P,%26+i TO %x >> 3,%v+(P >> 1): ELSE TILE 1,2 AT %P-4+i,28 TO %x >> 3+(P MOD 3),%v

  %P=%$ffff: ; now we're not moving
ENDPROC
;
; change direction and face the goodie
;
DEFPROC chaseGoodie(): ; UNUSED
  ; if baddie(x) = goodie(x)
  IF %y=0 THEN ENDPROC =%1
  IF %y=240 THEN ENDPROC =%0
  IF %f <> (x+32) THEN IF %f < (x+32) THEN ENDPROC =%2: ELSE IF %g < (y+48) THEN ENDPROC =%0: ELSE ENDPROC =%1

ENDPROC =%3
;
; handle baddies
;
DEFPROC updateBaddie()
  ; if this baddie is dead, fast exit
  IF %A[i+4]=0 THEN ENDPROC

  %f=% SPRITE AT (b,0): ; x
  %g=% SPRITE AT (b,1): ; y

  ; select a random direction 0-3 is valid, but if we have a random value higher
  ; then decide whether the baddie should chase the goodie, or keep going in the
  ; current direction
  ; DIFFICULTY is 1-5 - if 1, then the baddie is heading for you.
  ; if 5 it's entirely random
  ; otherwise it's 1 / DIFFICULTY * 2 rolls they go towards you or away
  ; but also roll the dice to decide whether they're even going to turn
  %j=% RND 12
  ;IF %j > 3 THEN : ELSE IF % RND ( INT {DIFFICULTY}*3)=0 THEN IF %f <> (x+32) THEN IF %f < (x+32) THEN %j=%2: ELSE IF %g < (y+48) THEN %j=%0: ELSE %j=%1: ELSE %j=%A[i+3]:
  IF %j > 3 THEN %j=%A[i+3]

  ; if they're on the edge of the map, don't let them walk off
  IF %g=208 THEN IF %j=0 THEN %j=1
  IF %g=48 THEN IF %j=1 THEN %j=0
  IF %f=272 THEN IF %j=2 THEN %j=3
  IF %f=32 THEN IF %j=3 THEN %j=2

  ; save their direction
  %A[i+3]=%j
  %A[(i*j)+2]=0

  ; this handles an edge case whereby the baddie is being revealed from hiding
  ; and they're not on the right Y plane, so the distance to the next intersection is adjusted
  %v=%48
  IF %(f-32) MOD 48 <> 0 THEN %v=%32: IF %j < 2 THEN %j=2

  ; Note: I don't make use of the sprite mirror flag, instead I'm storing all the permutations of the sprite
  ; because I have room, and it means that I don't need an IF and subsequent SPRITE statement, i.e. the
  ; fastest code is no code.
  %e=%A[i+5]
  IF %j=0 THEN SPRITE CONTINUE %b, STOP ,%g TO %g+40 STEP %z RUN ,%e-4 TO %e-3, BIN 10,0,0: ENDPROC : ; down
  IF %j=1 THEN SPRITE CONTINUE %b, STOP ,%g-40 TO %g STEP % SGN {-z} RUN ,%e-2 TO %e-1, BIN 10,0,0: ENDPROC : ; up
  IF %j=2 THEN SPRITE CONTINUE %b,%f TO %f+v STEP %z RUN , STOP ,%e TO %e+1, BIN 10,0,0: ENDPROC : ; right
  IF %j=3 THEN SPRITE CONTINUE %b,%f-v TO %f STEP % SGN {-z} RUN , STOP ,%e+2 TO %e+3, BIN 10,0,0: ENDPROC : ; left
ENDPROC
;
DEFPROC takeLife()
  FOR %i=1 TO 3
    SPRITE %50+i,%136+(i*14),%26,54,%i < l
  NEXT %i
  %l=%l-1
ENDPROC
;
DEFPROC up(%z): ; move up
  %P=2
  %y=%y-z
  %d=%d^@1000
  %s=50
ENDPROC
;
DEFPROC down(%z): ; move down
  %P=0
  %y=%y+z
  %d=%d^@1000
  %s=51
ENDPROC
;
DEFPROC left(%z): ; move left
  %P=4
  %x=%x-z
  %d=%@1001
  %s=%s+1: IF %s > 49 THEN %s=48
ENDPROC
;
DEFPROC right(%z): ; move right
  %P=6
  %x=%x+z
  %d=%@0001
  %s=%s+1: IF %s > 49 THEN %s=48
ENDPROC
;
DEFPROC pad(%w)
  IF %w < 10 THEN ENDPROC ="000"
  IF %w < 100 THEN ENDPROC ="00"
  IF %w < 1000 THEN ENDPROC ="0"
ENDPROC =""
;
DEFPROC printScore()
  IF %w < 1001 THEN PROC pad(%w) TO w$
  PRINT AT 0,0;"Score ";w$;%w
ENDPROC
;
; init functions
;
DEFPROC initSprites()
  SPRITE CLEAR : LAYER 2,1: SPRITE BORDER 1: SPRITE PRINT 1
  BANK 19 CLEAR
  BANK 23 COPY TO 19: ; reset the map
  TILE DIM 19,0,32,8: ; using tile bank 19, offset 0, tile 32 wide, tile size 8
  TILE 32,24: ; print tile for 14 tile cols by 12 tile rows
  TILE DIM 27,0,4,8: ; swap to our tomb tile set
  SPRITE STOP : ; switch to batching (though pretty sure this isn't required)
  ;
  ; FIXME this shouldn't be poked on each level
  ;
  ; footfall marks
  DATA 63,145,63,147,63,149,63,151
  DATA 144,63,146,63,148,63,150,63
  ; now we're going to push tiles into memory for feet
  FOR %i=%0 TO %7: READ %j: BANK %19 POKE %i,%j: NEXT %i
  FOR %i=%0 TO %7: READ %j: BANK %19 POKE %i+32,%j: NEXT %i
  ;
  ; tombopen/empty @ y:3
  DATA 28,29,29,25
  DATA 20,45,45,21
  DATA 26,22,22,27
  ; Pharaoh @ y:6 (openTomb, %j=1)
  DATA 64,65,68,69
  DATA 66,67,70,71
  DATA 80,81,84,85
  ; key @ y:9 (openTomb, %j=2)
  DATA 72,73,76,77
  DATA 74,75,78,79
  DATA 88,89,92,93
  ; scroll @ y:12 (openTomb, %j=3)
  DATA 96,97,100,101
  DATA 98,99,102,103
  DATA 112,113,116,117
  ; mummy @ y:15 (openTomb, %j=4)
  DATA 62,62,62,62
  DATA 62,62,63,63
  DATA 62,62,63,63
  ; chest @ y:18 (openTomb, %j=5)
  DATA 104,105,108,109
  DATA 106,107,110,111
  DATA 120,121,124,125

  ; update the tile bank (19) with these new tiles
  FOR %j=%3 TO %20
    FOR %i=%0 TO %3
      READ %k
      BANK %19 POKE %i+(j << 5),%k
    NEXT %i
  NEXT %j

  RESTORE 10: ; reset the position of read for new games
  PAPER 0: INK 236: BORDER 6: ;background black (6 = yellow), text white
ENDPROC
;
DEFPROC gameOver()
  PAPER 0: INK 255
  ; FIXME this should be done with a layer erase
  ; cheap black out
  PRINT AT 7,7;"                  "
  PRINT AT 8,7;"                  "
  PRINT AT 9,7;"                  "
  PRINT AT 10,7;"                  "
  PRINT AT 11,7;"                  "
  PRINT AT 12,7;"                  "
  PRINT AT 13,7;"                  "
  PRINT AT 14,7;"                  "
  PRINT AT 15,7;"                  "
  PRINT AT 16,7;"                  "
  FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  PRINT AT 12,8;"G": FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  PRINT AT 12,10;"A": FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  PRINT AT 12,12;"M": FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  PRINT AT 12,14;"E": FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  PRINT AT 12,17;"O": FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  PRINT AT 12,19;"V": FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  PRINT AT 12,21;"E": FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  PRINT AT 12,23;"R": FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  INK 224
  PRINT AT 15,7;"     you ded      "
  REPEAT : REPEAT UNTIL INKEY$ <> "" OR IN 31=16:
  SPRITE CLEAR
ENDPROC
;
; initBaddies: %A=Array[[x,y,spr,angle(0: x, 1: y),direction(0: backward, 1: forward),alive]] (allowing for more than 10 baddies)
; note: i*j = j properties per baddie
DEFPROC initBaddies()
  LET %j=6: ;n props
  FOR %i=1 TO %c: ;always have 9 baddie to update, to keep the rate constant
    LET %A[i*j]=%( RND 6)*48: ; 0 = x
    LET %A[(i*j)+1]=%40+( RND 4*40): ; 1 = y - baddies start on bottom 3 rungs
    LET %A[(i*j)+2]=0: ; 2 = delay (used to be SPRITE)
    LET %A[(i*j)+3]=% RND 4: ;3 = qaop/direction
    ; if we're on the last baddie, then we'll set them to dead, but they'll come to life later
    IF %i=1 THEN %A[(i*j)+4]=%$0: ELSE %A[(i*j)+4]=%$ff: ; 4 = alive (note to self: I changed this to 1 and baddie walked backwards)
    LET %A[(i*j)+5]=%44-(8*(c-i)): ; 5 = sprite offset (for baddie type)
    SPRITE %i,%A[i*j]+32,%A[(i*j)+1]+48,%A[(i*j)+5],%1&A[(i*j)+4]
  NEXT %i
ENDPROC
;
DEFPROC initTombs()
  FOR %i=0 TO 20: ; note that index 20 is used for dumping invalid/out of bounds
    LET %T(i)=%$f0: ; this is 11110000 - each edge is the high nibble and set as closed/waiting to be masked later
  NEXT %i
  PROC pickRandom()

  ; %W(3)=%4 :; use to force hidden baddie position

  ; generates: scroll (0), archaeologist (1), key (2), hidden mummy/baddie (3)
  FOR %i=%0 TO %3
    %T(W(i))=%T(W(i))+(i+1)
  NEXT %i

  ; PRINT AT 22,0;"Hidden @ ";%W(3)

  ; hides the baddie in a tomb
  %A[6]=%(W(3) MOD 5)*48+32+32
  %A[7]=%(W(3)/5)*40+24+48
  SPRITE 1,%A[6],%A[7],,,
  ;
  ; treasures x 5
  FOR %i=%4 TO %9
    %T(W(i))=%T(W(i))+5
  NEXT %i
ENDPROC
;
DEFPROC pickRandom()
  LOCAL %n: LOCAL %p: LOCAL %t
  %v=20: ; select from 0-20 (excluding 20)
  %p=14: ; pick 4 numbers
  %i=0
  ; init the 0-N array
  REPEAT
    %S(i)=%i
    %i=%i+1
  REPEAT UNTIL %i=v
  ; then go back downwards for P values
  REPEAT
    %t=% RND i
    %W(v-i)=%S(t): ; W is our global (winning positions)
    %i=%i-1
    %S(t)=%S(i)
  REPEAT UNTIL %i=(v-p)
  ; pickings are in global array W
ENDPROC
;
DEFPROC loadAssets()
  LAYER CLEAR
  LAYER 2,1
  PAPER 252: INK 0: BORDER 0:
  ;CLS
  SPRITE CLEAR
  ; allows for stop and start when music is running still
  ON ERROR CONTINUE : DRIVER 50,4: ON ERROR
  ON ERROR CONTINUE :.uninstall "assets/nextdaw.drv" : ON ERROR
  .install "assets/nextdaw.drv"
  LOAD "assets/mummy.ndr" BANK 20: ; plus bank 21 for music
  LOAD "assets/m-sprites.spr" BANK 22: SPRITE BANK 22
  LOAD "assets/mummy.map" BANK 23: ;load tile map created at https://zx.remysharp.com/sprites/
  LOAD "assets/m-tiles.spr" BANK 24: TILE BANK 24: ; load spritesheet for tiles
  LOAD "assets/banner.bin" BANK 25: ; header for non-game screens
  LOAD "assets/tokens.map" BANK 26
  LOAD "assets/tombs.map" BANK 27
  LOAD "assets/font.bin" CODE 64000
ENDPROC
;
DEFPROC initOnce()
  PROC loadAssets(): ; separate load allows for future single tape loader

  PLAYING=0
  DIFFICULTY=4
  SPEED=3
  MUSIC= NOT DEBUG

  ; music
  DRIVER 50,1,0,20: ; BANK21
  DRIVER 50,1,1,21: ; BANK21
  DRIVER 50,2: ; Init Song
  IF MUSIC THEN DRIVER 50,3: ; Play Song

  ; font
  DPOKE 23606,63744: ; 64000-256
  LAYER 2,1
  PRINT CHR$ 2: ; trigger the font to be loaded

  POKE 23658,0: ; turn off CAPS LOCK (for menu items)
ENDPROC
;
DEFPROC initGameVars()
  LET %x=96: LET %y=-16: LET %s=51: ; s=sprite
  LET %d=1: ; direction & speed
  LET %P=%0: ; %P = last player position
  LET %a=%$ffff
  LET %r=%0: ; can player kill a mummy?
  LET %t=%3
ENDPROC
;
DEFPROC initNewGame()
  %w=0: ; score
  ; define player and game state
  LET %z=%16-( INT {SPEED}*2): ; baddie speed
  LET %c=1: ; global badie count
  LET %l=3: ; lives
  PROC welcome()
  ;
  PLAYING=1
  PROC nextLevel(0)
ENDPROC
;
DEFPROC nextLevel(l)
  RANDOMIZE 0
  LEVEL=l+1
  %c=% INT {LEVEL}+1
  ; count how many baddies are left over, and carry them across
  ; %v=%0
  ; FOR %j=1 TO %c
  ;   IF %A[(j*6)+4]=$ff THEN %v=%v+1
  ; NEXT %j
  ; %c=%v+1

  ; adjust the cpu speed depending on the baddie count
  ; IF %c < 3 THEN RUN AT 2: ELSE IF %c < 4 THEN RUN AT 3: ELSE RUN AT 3

  PROC initSprites()
  PROC initBaddies()
  PROC initTombs()
  PROC initGameVars()
  PROC treadMark(): ; depends on player position
  %l=%l+1: ; stupid, but can't be bothered to add more code
  PROC takeLife(): ; renders the lives

  %w=%w+ INT {(LEVEL-1)*50}

  PROC printScore()

  ; show how many archaeologist's are left to save
  FOR %i=2 TO LEVEL
    SPRITE %55+i,%168+(i*16),%24,52,1
  NEXT %i
  FOR %i=LEVEL+1 TO 6
    SPRITE %55+i,%168+(i*16),%24,53,1
  NEXT %i

ENDPROC
;
DEFPROC dT()
  LET %g=% PEEK 23672
  LET %f=%g-n
  IF %g < n THEN LET %f=%f+256
  LET %n=%g
ENDPROC =%f
;
DEFPROC splash()
  LAYER 2,1: CLS
  .bmpload assets/welcome.bmp
  PAUSE 0
  LAYER CLEAR : PALETTE CLEAR
ENDPROC
;
DEFPROC optionsScreen()
  PROC header()

  LET %y=7
  DIFFICULTY=0
  %z=0

  PRINT AT %y+1,2;"Speed of game [1-5] ? █"
  PRINT AT %y+2,2;"    (1 is fastest)"
  PAUSE 100
  REPEAT
    SPRITE MOVE INT
    LET %j=% INT { CODE INKEY$ }-$30
    IF %j < 6 THEN %z=%j
  REPEAT UNTIL %z <> 0
  PRINT AT %y+1,24;%z
  SPEED=%z
  %z=%16-(z*2)
  REPEAT : REPEAT UNTIL INKEY$ ="": ; wait until the key is up again

  PRINT AT %y+4,2;"Difficulty level [1-5] ? █"
  PRINT AT %y+5,2;"    (1 is hardest)"
  REPEAT
    SPRITE MOVE INT
    LET %j=% INT { CODE INKEY$ }-$30
    IF %j < 6 THEN DIFFICULTY=%j
  REPEAT UNTIL DIFFICULTY <> 0
  PRINT AT %y+4,27;DIFFICULTY

  REPEAT : REPEAT UNTIL INKEY$ ="": ; wait until the key is up again

  MUSIC=2
  PRINT AT %y+7,2;"Background music [Y-N] ? █"
  REPEAT
    SPRITE MOVE INT
    c$= INKEY$
    IF c$="n" THEN MUSIC=0: PRINT AT %y+7,27;"No"
    IF c$="y" THEN MUSIC=1: PRINT AT %y+7,27;"Yes"
  REPEAT UNTIL MUSIC < 2

  IF MUSIC=0 THEN DRIVER 50,4: ELSE DRIVER 50,2: DRIVER 50,3

  REPEAT : REPEAT UNTIL INKEY$ ="": ; wait until the key is up again

ENDPROC
;
DEFPROC creditScreen()
  PROC header()

  LET %y=7

  PRINT AT %y,1;"CREDITS"
  PRINT AT %y+2,1;"Written by Remy Sharp";
  PRINT AT %y+3,1;"https://remysharp.com / @rem"
  PRINT AT %y+5,1;"Sprites by Remy's kids"
  PRINT AT %y+7,1;"Music by Richard Faulkner"
  PRINT AT %y+9,1;"Triology font by ZX-SOFT"

  PAPER 0: INK 252
  PRINT AT %y+13,19;" Continue..."
  PAPER 252: INK 0

  REPEAT : SPRITE MOVE INT : REPEAT UNTIL INKEY$ <> ""
ENDPROC
;
DEFPROC helpScreen()
  PROC header()

  LET %y=7
  PRINT AT %y,1;"Rescue the original 1984"
  PRINT AT %y+1,1;"archaeologist party from their";
  PRINT AT %y+2,1;"failed pyramid plundering."
  PRINT AT %y+4,1;"Navigate five tombs, avoiding"
  PRINT AT %y+5,1;"the guardians, rescue those"
  PRINT AT %y+6,1;"muppets and bring them"
  PRINT AT %y+7,1;"back to Blighty."
  PAPER 0: INK 252
  PRINT AT %y+13,19;" Continue..."
  PAPER 252: INK 0
  REPEAT : SPRITE MOVE INT : REPEAT UNTIL INKEY$ <> ""
  ; the tokens

  PROC header()
  TILE DIM 27,24,4,8
  TILE 4,3 AT  0,0 TO 2,%y
  TILE 4,3 AT 12,0 TO 2,%y+3
  TILE 4,3 AT 24,0 TO 2,%y+6
  TILE 4,3 AT 48,0 TO 2,%y+9

  PRINT AT %y+1,6;"Rescue this dude"
  PRINT AT %y+4,6;"Key to escape the tomb"
  PRINT AT %y+7,6;"Vanquish a guardian"
  PRINT AT %y+10,6;"Gems means hi-scores"

  PAPER 0: INK 252
  PRINT AT %y+13,19;" Continue..."
  PAPER 252: INK 0

  REPEAT : SPRITE MOVE INT : REPEAT UNTIL INKEY$ <> ""

  PROC header()

  LET %y=7

  PRINT AT %y,2;"CONTROLS"
  PRINT AT %y+2,2;"Kempton joystick and keyboard";
  PRINT AT %y+4,2;"Q= up"
  PRINT AT %y+5,2;"A= down"
  PRINT AT %y+6,2;"O= left"
  PRINT AT %y+7,2;"P= right"

  PRINT AT %y+10,2;"Surround a tomb to reveal the"
  PRINT AT %y+11,2;"contents. Don't get chomped!"

  PAPER 0: INK 252
  PRINT AT %y+13,19;" Continue..."
  PAPER 252: INK 0

  REPEAT : SPRITE MOVE INT : REPEAT UNTIL INKEY$ <> ""

  PROC creditScreen()

ENDPROC
;
DEFPROC header()
  PAPER 252: INK 0: BORDER 0
  ; important: I'm not using CLS as this method is faster
  ; otherwise there's a visible screen clear and reset
  BANK 25 COPY TO 9: ; "Oh Mummy header"
  BANK 10 ERASE 252
  BANK 11 ERASE %0,%$3000,252
  BANK 11 ERASE %$3000,%$1000,0: ; last 4k is black
ENDPROC
;
DEFPROC playScreen()
  PROC header()

  LET %y=9

  PRINT AT %y,4;"Rescue the archaeologists"
  PRINT AT %y+2,6;"    Save the day!"
  PRINT AT %y+4,6;"   Don't get eaten"
  PRINT AT %y+11,0; PAPER 0; INK 252;"                                "
  PRINT AT %y+12,0; PAPER 0; INK 252;"I-Instructions O-Options P-Play "

ENDPROC
;
DEFPROC welcome()
  IF DEBUG THEN ENDPROC : ; FIXME remove
  PLAYING=0
  SPRITE CLEAR
  SPRITE BORDER 0
  SPRITE BANK 22
  SPRITE STOP : ; switch to batching (though pretty sure this isn't required)
  SPRITE PRINT 1

  LET %x=304: LET %y=208
  SPRITE 64,%x,%y,48,%@1001
  SPRITE 63,%x,%y,46,1

  SPRITE CONTINUE 64,0 TO %x STEP -8 RUN , STOP ,48 TO 49, BIN 0001000,3,200
  SPRITE CONTINUE 63,0 TO %x STEP -8 RUN , STOP ,46 TO 47, BIN 0001000,3,225

  CLS
  PROC playScreen()

  REPEAT
    SPRITE MOVE INT
    c$= INKEY$
    IF c$="i" THEN PROC helpScreen(): PROC playScreen()
    IF c$="o" THEN PROC optionsScreen(): PROC playScreen()
  REPEAT UNTIL c$="p"

  LAYER CLEAR : PALETTE CLEAR

ENDPROC
;
DEFPROC exit()
  ERROR TO err,lin,st
  ON ERROR
  e$= STR$ err
  ; use break to exit mid-game
  IF err > 9 THEN e$= CHR$ (err+55)
  IF err=21 AND PLAYING THEN PROC initNewGame(): PROC mainLoop(): ENDPROC
  IF DEBUG THEN : PRINT CHR$ 30,: PRINT "Error:";e$;", line:";lin;", statement:";st: REPEAT : REPEAT UNTIL INKEY$ ="": REPEAT : REPEAT UNTIL INKEY$ <> ""

  DRIVER 50,4
  .uninstall "assets/nextdaw.drv"
  PALETTE CLEAR
  LAYER CLEAR
  SPRITE CLEAR
  CLS
  BORDER 7
  GO TO 9999
ENDPROC
;
#autoline
9900 CLEAR : PALETTE CLEAR : LAYER CLEAR : SPRITE PRINT 0: SAVE "mummy.bas" LINE 0: STOP
9999 REG 2,1: ; soft reset
