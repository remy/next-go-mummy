#program mummy
#autostart 10
#autoline 10
; Oh Mummy (clone), Remy Sharp 2020
;
RUN AT 3: REM 3.5Mhz (0 = 3.5, 1 = 7 (aim), 2 = 14 (likely))
LET S$="MUMMY-R"
;
; ************ TODO ***************
; - [ ] Fix tomb 9 affecting tomb 10
; - [ ] Fix the top left corner foot steps
; - [ ] Bug tomb 0
; - [ ] AI for baddie & dumb baddies
; - [~] Welcome screen / start game
; - [x] Score
; - [x] 10 treasure chests
; - [x] Open tomb effect (spr@8-11 + 12 transparency)
; - [x] Level up
; - [x] Graphics for prize tombs
; - [x] Possibly allow player in start position?
;
; ******** VARIABLE INDEX *********
;
; %a = player last corner, used for tomb calc - initilised to $FF
; %A[] = baddie array (allows for > 64 elements)
; %b = baddie index
; %c = baddie count
; %d = player sprite flags (mirror, etc)
; %e = BANK that's used to track where the baddies are
; %n = delta time counter (only used during dev, but needs to be reserved)
; %l = player lives
; %P = player last position, used for tread marks - initilised to $FFFF
; %q = player last direction (whilst movement is engaged)
; %r = (flag) player has scroll and can kill a mummy
; %s = player sprite
; S$ = sprite filename prefix (mummy and mummy-r for retro)
; %T(21) = tomb array 0-19 with index 20 used for temp rendering, with 8bit flags (14 items contain data in the low bit)
; %t = items to find - defaults to 2
; %w = score
; %x = player x
; %y = player y
; %z = sprite speed (for both baddie) - calculated based on DIFFICULTY
; --- non int vars ---
; DIFFICULTY = how fast/smart the mummy's are (currently not!)
; LEVEL = current level
;
; TMP VARIABLES
; i, j, k - then - f, g, h, m, o, q, u, v
; **********************************
;
; clean the screen on stop
;ON ERROR : ERROR TO er,lin,st: PROC cleanUp(er,lin,st)
;
;PROC dT()
PROC splash()
PROC initOnce()
PROC initNewGame()
; core loop
REPEAT
  REPEAT
    IF INKEY$ ="t" THEN %t=0: ; FIXME remove TESTING ONLY
    PROC updateLoop(): ; update logic and render
  REPEAT UNTIL %l=0 OR (t=0): ; until zero lives
  IF %t=0 THEN PROC nextLevel(LEVEL): ELSE PROC gameOver(): PROC initNewGame()
REPEAT UNTIL 0: ; repeat forever
;
; start main game loop - we do only one thing at a time in the main loop
DEFPROC updateLoop()
  PROC updatePlayer(%8)
  LET %b=1: ; baddie loop
  REPEAT
    %i=%b*6: ; 6 props (easy to mess this up!)
    IF % SPRITE CONTINUE b < 2 THEN PROC updateBaddie(%A[i+2])
    LET %b=%b+1
  REPEAT UNTIL %b=(c+1)
  SPRITE MOVE INT
  ;PROC dT() TO %f: PRINT AT 0,0;%c;"@";%f;" ": ; f big = bad, small = good
ENDPROC
;
DEFPROC updatePlayer(%z)
  PROC treadMark(): ; put treadmarks on the place we're about to move away from

  LET %j= IN 31: ; check the joystick and then keys

  IF %( IN $fbfe >> 0&1^1) THEN LET %j=%j+@1000: ; Q
  IF %( IN $fdfe >> 0&1^1) THEN LET %j=%j+@0100: ; A
  IF %( IN $dffe >> 1&1^1) THEN LET %j=%j+@0010: ; O
  IF %( IN $dffe >> 0&1^1) THEN LET %j=%j+@0001: ; P

  ; NOTE I no longer do an early exit - this keeps the game speed constant, otherwise the baddies speed up
  ; IF %j&$0f=0 THEN LET %P=%$ffff: ENDPROC : ; play isn't moving, early exit

  ; if I can't move on x plane, check y
  IF %x MOD 48 THEN : ELSE : IF %j&@0100 THEN PROC down(%z): ELSE IF %y > 0 AND (j&@1000) THEN PROC up(%z)
  ; IF %P <> $ffff THEN
  PROC checkTomb(): ; %P = $ffff if they haven't moved

  IF %y MOD 40 OR (y > $ff) THEN : ELSE : IF %j&@0010 THEN PROC left(%z): ELSE IF %j&@0001 THEN PROC right(%z)

  ; note that %x > $ff means the integer has gone from 0, to -1, but it's unsigned
  ; so it'll be up in the 65K range, so this check against 255 is good enough
  IF %x > $ff THEN : LET %x=0: ELSE IF %x > 240 THEN : LET %x=240

  IF %t=1 THEN IF %j&@1000 AND (y=0) AND (x=96) THEN PROC up(%z):%t=0: SPRITE 64,%x+32,%y+48,%s,%d: ENDPROC
  IF %y=$FFF0 OR (y=$FFF8) THEN : ELSE : IF %y > $ff THEN : LET %y=0: ELSE IF %y > 160 THEN : LET %y=160

  ; IF %P <> $ffff THEN
  PROC checkTomb()

  SPRITE 64,%x+32,%y+48,%s,%d

  %i=% SPRITE OVER (64,1 TO c)
  IF %i=0 THEN ENDPROC
  SPRITE %i,,,,0
  %i=%i*6
  IF %A[i+4]=0 THEN ENDPROC
  %A[i+4]=0
  %A[i+5]=0
  IF %r=0 THEN PROC takeLife(): ELSE %r=0
ENDPROC
;
DEFPROC checkTomb()
  IF %(x MOD 48) OR (y MOD 40) THEN PAUSE 1: ENDPROC : ; only run on corners
  LET %i=%(6*(y/40))+(x/48): ; x/y as aisle index (6 aisles for 5 rows of tombs)
  IF %i=a THEN PAUSE 1: ENDPROC : ; we were just there (%a is last position)
  IF %a=$ffff THEN %a=%i: PAUSE 1: ENDPROC

  %f=%i-a: ; f is forward +1 or backward -1
  %k=% ABS SGN {f}=1: ; k tracks the axis, +1 for X, 0 for Y

  IF % SGN {f < 0} THEN %g=%a: ELSE %g=%i
  IF %k THEN PROC getXTombs() TO %g,%h: ELSE PROC getYTombs() TO %g,%h
  IF %g > 20 THEN %g=20: ; assign out of bounds to the junk element (index 20)
  IF %h > 20 THEN %h=20
  ; bitwise op below is $current wall & (0xF0 + wall, 1 top, 2 right, 4 bottom, 8 left)
  ; importantly this leaves the first 4 bits untouched
  IF %k THEN %T(g)=%T(g)&@11011111:%T(h)=%T(h)&@01111111: ELSE %T(g)=%T(g)&@10111111:%T(h)=%T(h)&@11101111
  IF %T(g)&$f8=0 THEN PROC openTomb(%g): ; (value & 0xf8)==0 = all the walls are covered, and bit 4 (0x08) is _not_ set - then open the tomb
  IF %T(h)&$f8=0 THEN PROC openTomb(%h)
  ;
  LET %a=%f+a: ; save the last position (because we lost %i)
ENDPROC
;
DEFPROC getXTombs(): ; uses scoped %g var from checkTomb
  %h=%1+(g/6)
  %i=%g-h
ENDPROC =%i-5,%i
;
DEFPROC getYTombs(): ; uses scoped %g var from checkTomb
  %i=%g-6-(g/6)
ENDPROC =%i,%i+1
;
DEFPROC openTomb(%i)
  LOCAL %j
  %j=%T(i)
  IF %i=20 THEN ENDPROC
  IF %j&8=8 THEN ENDPROC : ; Tomb is open, exit FIXME is this always false?
  ;
  LOCAL %y
  %y=%(3*j)+3
  ; I can't remember why this line ends with 4+i*5/5, but I did work it out
  ; and when I just do %4+i the tile drawing messes up, where as this is fine...
  TILE 4,3 AT 0,%y TO %2+((i MOD 5)*6),%4+((i/5)*5)
  ; pharoh, key, scroll or treasure (in that order) (currently missing new mummy/guardian)
  IF %j=1 THEN %t=%t-1:%w=%w+50: ELSE IF %j=2 THEN %t=%t-1: ELSE IF %j=3 THEN %r=%1: ELSE IF %j=5 THEN %w=%w+5
  IF %t=0 THEN PAUSE 0
  %T(i)=%j+8: ; prevent the tomb from being reopened
  PROC printScore()
ENDPROC
;
; leave tread marks
DEFPROC treadMark(): ;down=0,up=2,left=4,right=6
  ; ON ERROR : ENDPROC : ; this happens at the end of a level
  IF %P=$ffff THEN ENDPROC : ; didn't move
  IF %P=4 THEN LET %i=%2: ELSE LET %i=%0: ; if left +1, right = -1
  IF %P=2 THEN LET %j=%1: ELSE LET %j=%0
  ;
  IF %P > 3 THEN %k=%(x >> 3) MOD 2: ELSE %k=%(y >> 3) MOD 2:%i=%k:%j=%k
  ;
  %v=%y >> 3+j+2
  IF %v > 8000 THEN %v=%v MOD 8192: ; handle when player is in start position
  TILE 1,2 AT %P+k,0 TO %x >> 3+i,%v
  %P=%$ffff: ; now we're not moving
ENDPROC
;
; handle baddies
;
DEFPROC updateBaddie(%d)
  ; if this baddie is dead, fast exit
  IF %A[i+4]=0 THEN ENDPROC

  %f=% SPRITE AT (b,0): ; x
  %g=% SPRITE AT (b,1): ; y

  ; random 0-11 - 0-3 is valid, > 3 is don't change direction
  %j=% RND 12
  IF %j > 3 THEN %j=%A[i+3]

  ; if they're on the edge of the map, don't let them walk off
  IF %g=208 THEN IF %j=0 THEN %j=1
  IF %g=48 THEN IF %j=1 THEN %j=0
  IF %f=272 THEN IF %j=2 THEN %j=3
  IF %f=32 THEN IF %j=3 THEN %j=2

  ; save their direction
  %A[i+3]=%j
  %A[(i*j)+2]=0

  ; Note: I don't make use of the sprite mirror flag, instead I'm storing all the permutations of the sprite
  ; because I have room, and it means that I don't need an IF and subsequent SPRITE statement, i.e. the
  ; fastest code is no code.

  IF %j=0 THEN SPRITE CONTINUE %b, STOP ,%g TO %g+40 STEP %z RUN ,40 TO 41, BIN 10,0,%d: ENDPROC : ; down
  IF %j=1 THEN SPRITE CONTINUE %b, STOP ,%g-40 TO %g STEP % SGN {-z} RUN ,42 TO 43, BIN 10,0,%d: ENDPROC : ; up
  IF %j=2 THEN SPRITE CONTINUE %b,%f TO %f+48 STEP %z RUN , STOP ,44 TO 45, BIN 10,0,%d: ENDPROC : ; right
  IF %j=3 THEN SPRITE CONTINUE %b,%f-48 TO %f STEP % SGN {-z} RUN , STOP ,46 TO 47, BIN 10,0,%d: ENDPROC : ; left
ENDPROC
;
DEFPROC takeLife()
  LET %l=%l-1
  FOR %i=0 TO 2
    SPRITE %55+i,%200+(i*16),%24,%48+(i MOD 2),%i < l: ; draw lives
  NEXT %i
ENDPROC
;
DEFPROC up(%z): ; move up
  %P=2
  %y=%y-z
  %d=%d^@1000
  %s=50
ENDPROC
;
DEFPROC down(%z): ; move down
  %P=0
  %y=%y+z
  %d=%d^@1000
  %s=51
ENDPROC
;
DEFPROC left(%z): ; move left
  %P=4
  %x=%x-z
  %d=%@1001
  %s=%s+1: IF %s > 49 THEN %s=48
ENDPROC
;
DEFPROC right(%z): ; move right
  %P=6
  %x=%x+z
  %d=%@0001
  %s=%s+1: IF %s > 49 THEN %s=48
ENDPROC
;
DEFPROC pad(%w)
  IF %w < 10 THEN ENDPROC ="000"
  IF %w < 100 THEN ENDPROC ="00"
  IF %w < 1000 THEN ENDPROC ="0"
ENDPROC =""
;
DEFPROC printScore()
  IF %w < 1001 THEN PROC pad(%w) TO w$
  PRINT AT 0,0;"Score ";w$;%w
ENDPROC
;
; init functions
;
DEFPROC initSprites()
  SPRITE CLEAR : LAYER 2,1: CLS : SPRITE BORDER 1: SPRITE PRINT 1
  TILE DIM 14,0,32,8: ; using tile bank 14, offset 0, tile 32 wide, tile size 8
  LOAD S$+".map" BANK 14: ; load tile map created at https://zx.remysharp.com/sprites/
  TILE 32,24: ; print tile for 16 tile cols by 12 tile rows
  LOAD S$+".spr" BANK 16,0,4096
  SPRITE BANK 13
  ; SPRITE STOP : ; switch to batching
  ;
  ; footfall marks
  DATA 63,145,63,147,63,149,63,151
  DATA 144,63,146,63,148,63,150,63
  ; now we're going to push tiles into memory for feet
  FOR %i=%0 TO %7: READ %j: BANK %14 POKE %i,%j: NEXT %i
  FOR %i=%0 TO %7: READ %j: BANK %14 POKE %i+32,%j: NEXT %i
  ;
  ; tombopen/empty @ y:3
  DATA 11,11,11,11
  DATA 11,11,11,11
  DATA 11,11,11,11
  ; Pharaoh @ y:6 (openTomb, %j=1)
  DATA 64,65,68,69
  DATA 66,67,70,71
  DATA 80,81,84,85
  ; key @ y:9 (openTomb, %j=2)
  DATA 72,72,76,77
  DATA 74,75,78,79
  DATA 88,89,92,93
  ; scroll @ y:12 (openTomb, %j=3)
  DATA 96,97,100,101
  DATA 98,99,102,103
  DATA 112,113,116,117
  ; mummy @ y:15 (openTomb, %j=4)
  DATA 62,62,62,62
  DATA 62,62,63,63
  DATA 62,62,63,63
  ; chest @ y:18 (openTomb, %j=5)
  DATA 104,105,108,109
  DATA 106,107,110,111
  DATA 120,121,124,125

  FOR %j=%3 TO %20
    FOR %i=%0 TO %3
      READ %k
      BANK %14 POKE %i+(j << 5),%k
    NEXT %i
  NEXT %j

  RESTORE 10: ; reset the position of read for new games
  PAPER 0: INK 236: BORDER 6: ;background black (6 = yellow), text white
ENDPROC
;
DEFPROC gameOver()
  PAPER 0: INK 255
  ; cheap black out
  PRINT AT 7,7;"                 "
  PRINT AT 8,7;"                 "
  PRINT AT 9,7;"                 "
  PRINT AT 10,7;"                 "
  PRINT AT 11,7;"                 "
  PRINT AT 12,7;"                 "
  PRINT AT 13,7;"                 "
  PRINT AT 14,7;"                 "
  PRINT AT 15,7;"                 "
  PRINT AT 16,7;"                 "
  PAUSE 20
  PRINT AT 12,8;"G": PAUSE 20
  PRINT AT 12,10;"A": PAUSE 20
  PRINT AT 12,12;"M": PAUSE 20
  PRINT AT 12,14;"E": PAUSE 20
  PRINT AT 12,17;"O": PAUSE 20
  PRINT AT 12,19;"V": PAUSE 20
  PRINT AT 12,21;"E": PAUSE 20
  PRINT AT 12,23;"R": PAUSE 20
  INK 224
  PRINT AT 15,7;"     you ded      "
  REPEAT : REPEAT UNTIL INKEY$ ="s":
  PROC initNewGame(): ; setup new game
ENDPROC
;
; initBaddies: %A=Array[[x,y,spr,angle(0: x, 1: y),direction(0: backward, 1: forward),alive]] (allowing for more than 10 baddies)
; note: i*j = j properties per baddie
DEFPROC initBaddies()
  BANK %e ERASE
  LET %j=6: ;n props
  FOR %i=1 TO %c: ;always have 9 baddie to update, to keep the rate constant
    LET %A[i*j]=%( RND 6)*48: ; 0 = x
    LET %A[(i*j)+1]=%40+( RND 4*40): ; 1 = y - baddies start on bottom 3 rungs
    LET %A[(i*j)+2]=%i: ; 2 = delay (used to be SPRITE)
    LET %A[(i*j)+3]=% RND 4: ;3 = qaop/direction
    LET %A[(i*j)+4]=%$ff: ; 4 = alive (note to self: I changed this to 1 and baddie walked backwards)
    LET %A[(i*j)+5]=1: ; 5 = sprite flags
    ;BANK %e POKE %(32*(A[(i*j)+1] >> 3))+(A[i*j] >> 3),%i
    SPRITE %i,%A[i*j]+32,%A[(i*j)+1]+48,44,1
  NEXT %i
ENDPROC
;
DEFPROC initTombs()
  FOR %i=0 TO 20: ; note that index 20 is used for dumping invalid/out of bounds
    LET %T(i)=%$f0: ; this is 11110000 - each edge is the high nibble and set as closed/waiting to be masked later
  NEXT %i
  PROC pickRandom()
  ; generates: scroll, pharos, key, new mummy
  FOR %i=%0 TO %3
    %T(W(i))=%T(W(i))+(i+1)
  NEXT %i
  ; treasures x 10
  FOR %i=%4 TO %13
    %T(W(i))=%T(W(i))+5
  NEXT %i
ENDPROC
;
DEFPROC pickRandom()
  LOCAL %n: LOCAL %p: LOCAL %t
  %v=20: ; select from 0-20 (excluding 20)
  %p=14: ; pick 4 numbers
  %i=0
  ; init the 0-N array
  REPEAT
    %S(i)=%i
    %i=%i+1
  REPEAT UNTIL %i=v
  ; then go back downwards for P values
  REPEAT
    %t=% RND i
    %W(v-i)=%S(t): ; W is our global (winning positions)
    %i=%i-1
    %S(t)=%S(i)
  REPEAT UNTIL %i=(v-p)
  ; pickings are in global array W
ENDPROC
;
DEFPROC loadFont()
  LOAD "font.bin" CODE 64000
  DPOKE 23606,63744: ; 64000-256
  LAYER 2,1
  PRINT CHR$ 2: ; trigger the font to be loaded
ENDPROC
;
DEFPROC initOnce()
  CLS
  LAYER CLEAR
  SPRITE CLEAR
  LAYER 2,1
  LOAD S$+".spr" BANK 13: ; load spritesheet for tiles
  TILE BANK 13: ; point tiles to spritesheet
  %e=%15: ; game map bank
  DIFFICULTY=4
  RANDOMIZE % PEEK 23672
  PROC loadFont()
ENDPROC
;
DEFPROC initGameVars()
  LET %x=96: LET %y=-16: LET %s=51: ; s= SPRITE + 4 for old skoool
  LET %d=1: ; direction & speed
  LET %P=%0: ; %P = last player position
  LET %a=%$ffff
  LET %r=%0: ; can player kill a mummy?
  LET %t=%3
ENDPROC
;
DEFPROC initNewGame()
  %w=0: ; score
  ; define player and game state
  LET %z=%2* INT {DIFFICULTY}: ; baddie speed
  LET %c=1: ; global badie count
  LET %l=3: ; lives
  PROC welcome()
  ;
  PROC nextLevel(0)
ENDPROC
;
DEFPROC nextLevel(l)
  LEVEL=l+1
  ; count how many baddies are left over, and carry them across
  %v=%0
  FOR %j=1 TO %c
    IF %A[(j*6)+4]=$ff THEN %v=%v+1
  NEXT %j
  %c=%v+1

  ; adjust the cpu speed depending on the baddie count
  ; IF %c < 3 THEN RUN AT 2: ELSE IF %c < 4 THEN RUN AT 3: ELSE RUN AT 3

  PROC initSprites()
  PROC initBaddies()
  PROC initTombs()
  PROC initGameVars()
  PROC treadMark(): ; depends on player position
  %l=%l+1: ; stupid, but can't be bothered to add more code
  PROC takeLife(): ; renders the lives
  PROC printScore()
ENDPROC
;
DEFPROC dT()
  LET %g=% PEEK 23672
  LET %f=%g-n
  IF %g < n THEN LET %f=%f+256
  LET %n=%g
ENDPROC =%f
;
DEFPROC cleanUp(e,l,s)
  ON ERROR
  BANK CLEAR %e
  LAYER CLEAR
  SPRITE CLEAR
  CLS
  BORDER 7
  PRINT 0,0;"Error:";e;", ";l;":";s
  PAUSE 0
ENDPROC
;
DEFPROC splash()
  LAYER 2,1: CLS
  .bmpload welcome.bmp
  PAUSE 0
  LAYER CLEAR : PALETTE CLEAR
ENDPROC
;
DEFPROC welcome()
  TILE DIM 14,0,32,8: ; using tile bank 14, offset 0, tile 32 wide, tile size 8
  LOAD "welcome.map" BANK 14: ; load tile map created at https://zx.remysharp.com/sprites/
  TILE 32,24: ; print tile for 16 tile cols by 12 tile rows
  PAPER 0: INK 180: BORDER 6: ;background black (6 = yellow), text white

  PRINT AT 15,9;"Press any key"
  PAUSE 0

ENDPROC

;
;Quick save
;
CLEAR : LAYER CLEAR : SPRITE PRINT 0: SAVE "mummy.bas" LINE 0
