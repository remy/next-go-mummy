#program mummy
#autoline 10
; Oh Mummy (clone), Remy Sharp 2020
; ******** VARIABLE INDEX *********
;
; %a = player last corner, used for tomb calc - initilised to $FF
; b = baddie index
; A[] = baddie array (allows for > 64 elements)
; c = baddie count
; %d = player sprite flags (mirror, etc)
; %e = BANK that's used to track where the baddies are
; %l = player lives
; %P = player last position, used for tread marks - initilised to $FFFF
; %q = bank array of map and objects on map
; %r = current level
; %s = player sprite
; %T(21) = tomb array 0-19 with index 20 used for temp rendering, with 8bit flags
; %W(4) = array(4) of tombs with items behind theme
; %x = player x
; %y = player y
; %z = sprite speed (for both player and baddie) - constant at 8
;
; TMP VARIABLES
; i, j, k - then - f, g, h, m, n, o, q
; **********************************
;
RUN AT 3: REM 3.5Mhz (0 = 3.5, 1 = 7 (aim), 2 = 14 (likely))
RANDOMIZE %2
; clean the screen on stop
;ON ERROR TO e,l,s: PROC cleanUp(e,l,s)
;
PROC initOnce()
; core loop
REPEAT
  PROC initNewGame(): ; setup new game
  REPEAT
    PROC updateLoop(): ; update logic and render
  REPEAT UNTIL %l=0: ; until zero lives
  PROC gameOver(): ; then print game over
REPEAT UNTIL 0: ; repeat forever
;
; start main game loop - we do only one thing at a time in the main loop
DEFPROC updateLoop()
  PROC updatePlayer():
  LET %b=1: ; baddie loop
  REPEAT
    %i=%b*6: ; 6 props (easy to mess this up!)
    PROC updateBaddie(): SPRITE %b,%A[i]+32,%A[i+1]+48,%A[i+2],%A[i+5]&A[i+4]
    ; note: updatePlayer overwrites %i ... sorry.
    IF %b MOD 4=0 THEN PROC updatePlayer(): SPRITE MOVE :
    LET %b=%b+1
  REPEAT UNTIL %b=(c+1)
  SPRITE MOVE
  ; PROC fps(): PRINT AT 0,0;%f;"      ": ; f big = bad, small = good
ENDPROC
;
DEFPROC updatePlayer()
  PROC treadMark(): ; put treadmarks on the place we're about to move away from
  ;
  LET %j= IN 31: ; check the joystick and then keys
  ;
  IF %( IN $fbfe >> 0&1^1) THEN LET %j=%(j+@1000): ; Q
  IF %( IN $fdfe >> 0&1^1) THEN LET %j=%(j+@0100): ; A
  IF %( IN $dffe >> 1&1^1) THEN LET %j=%(j+@0010): ; O
  IF %( IN $dffe >> 0&1^1) THEN LET %j=%(j+@0001): ; P
  ;
  ; NOTE I no longer do an early exit - this keeps the game speed constant, otherwise the baddies speed up
  ; IF %j&$0f=0 THEN LET %P=%$ffff: ENDPROC : ; play isn't moving, early exit
  ;
  ; if I can't move on x plane, check y
  IF %x MOD 48 THEN : ELSE : IF %j&@0100 THEN PROC down(): ELSE IF %j&@1000 THEN PROC up()
  IF %P <> $ffff THEN PROC checkTomb(): ; %P = $ffff if they haven't moved
  ;
  IF %y MOD 40 THEN : ELSE : IF %j&@0010 THEN PROC left(): ELSE IF %j&@0001 THEN PROC right():
  ;
  ; note that %x > $ff means the integer has gone from 0, to -1, but it's unsigned
  ; so it'll be up in the 65K range, so this check against 255 is good enough
  IF %x > $ff THEN : LET %x=0: ELSE IF %x > 240 THEN : LET %x=240
  IF %y > $ff THEN : LET %y=0: ELSE IF %y > 160 THEN : LET %y=160
  ;
  IF %P <> $ffff THEN PROC checkTomb()
  ;
  SPRITE 64,%x+32,%y+48,%s,%d
  ;
  ENDPROC : ; FIXME remove to track lives
  %i=% SPRITE OVER (64,1 TO c)*6
  IF %i=0 THEN ENDPROC
  IF %A[i+4]=0 THEN ENDPROC
  %A[i+4]=0
  %A[i+5]=0
  PROC takeLife()
ENDPROC
;
DEFPROC checkTomb()
  IF %(x MOD 48) OR (y MOD 40) THEN ENDPROC : ; only run on corners
  LET %i=%(6*(y/40))+(x/48): ; x/y as aisle index (6 aisles for 5 rows of tombs)
  IF %i=a THEN ENDPROC : ; we were just there (%a is last position)
  ;
  %f=%i-a: ; f is forward +1 or backward -1
  %k=% ABS SGN {f}=1: ; k tracks the axis, +1 for X, 0 for Y
  ;
  IF % SGN {f < 0} THEN %g=%a: ELSE %g=%i
  IF %k THEN PROC getXTombs() TO %g,%h: ELSE PROC getYTombs() TO %g,%h
  IF %g > 20 THEN %g=20: ; assign out of bounds to the junk element (index 20)
  IF %h > 20 THEN %h=20
  ; bitwise op below is $current wall & (0xF0 + wall, 1 top, 2 right, 4 bottom, 8 left)
  ; importantly this leaves the first 4 bits untouched
  IF %k THEN %T(g)=%T(g)&@11011111:%T(h)=%T(h)&@01111111: ELSE %T(g)=%T(g)&@10111111:%T(h)=%T(h)&@11101111
  IF %T(g)&$f8=0 THEN PROC openTomb(%g): ; (value & 0xf8)==0 = all the walls are covered, and bit 4 (0x08) is _not_ set - then open the tomb
  IF %T(h)&$f8=0 THEN PROC openTomb(%h)
  ;
  LET %a=%i: ; save the last position
ENDPROC
;
DEFPROC getXTombs(): ; uses scoped %g var from checkTomb
  %h=%1+(g/6)
  %i=%g-h
ENDPROC =%i-5,%i
;
DEFPROC getYTombs(): ; uses scoped %g var from checkTomb
  %i=%g-6-(g/6)
ENDPROC =%i,%i+1
;
DEFPROC openTomb(%i)
  IF %i=20 THEN ENDPROC
  IF %T(i)&8=8 THEN ENDPROC : ; FIXME is this always false?
  ;
  PRINT AT 0,0;"tomb ";%i;" contained ";%T(i);" "
  PRINT AT 1,0;"i:";%i;",T(i):";%T(i)
  %T(i)=%T(i)+8: ; prevent the tomb from being reopened
ENDPROC
;
; leave tread marks
DEFPROC treadMark(): ;down=0,up=2,left=4,right=6
  IF %P=$ffff THEN ENDPROC : ; didn't move
  IF %P=4 THEN LET %i=%2: ELSE LET %i=%0: ; if left +1, right = -1
  IF %P=2 THEN LET %j=%1: ELSE LET %j=%0
  ;
  IF %P > 3 THEN %k=%(x/8) MOD 2: ELSE %k=%(y/8) MOD 2:%i=%k:%j=%k
  ;
  TILE 1,2 AT %P+k,0 TO %x/8+i,%y/8+j+2
  %P=%$ffff: ; now they're not moving
ENDPROC
;
; handle baddies
;
DEFPROC updateBaddie()
  LET %j=%A[i+3]
  IF %j=1 THEN PROC baddieD(): IF %A[i+1] MOD 40 THEN ENDPROC : ;down
  IF %j=2 THEN PROC baddieU(): IF %A[i+1] MOD 40 THEN ENDPROC : ;up
  IF %j=4 THEN PROC baddieL(): IF %A[i] MOD 48 THEN ENDPROC : ;left
  IF %j=8 THEN PROC baddieR(): IF %A[i] MOD 48 THEN ENDPROC : ;right
  ;
  ; rotate 1:3 times
  ; IF %A[i]=240 THEN %A[i+3]=4
  ; IF %A[i]=0 THEN %A[i+3]=8
  IF % RND 3=0 THEN LET %A[i+3]=%1 << RND 4: ;qaop/direction
ENDPROC
;
DEFPROC getIndexForXY(%x,%y)
ENDPROC =%(32*(y/8))+(x/8)
;
DEFPROC getBaddieBankIndex(%i)
  LOCAL %j
  PROC getIndexForXY(%A[i*6],%A[(i*6)+1]) TO %j
ENDPROC =%j
;
DEFPROC clearBaddie(%a)
  PROC setBaddieInBank(%a,%0)
ENDPROC
;
DEFPROC setBaddie(%a)
  PROC setBaddieInBank(%a,%a)
ENDPROC
;
DEFPROC setBaddieInBank(%a,%b)
  LOCAL %j
  PROC getBaddieBankIndex(%a) TO %j
  BANK %e POKE %j,%b
ENDPROC
;
DEFPROC peekForXY(%x,%y)
  LOCAL %j
  PROC getIndexForXY(%x,%y) TO %j
  %j=% BANK e PEEK j
ENDPROC =%j
;
DEFPROC getBaddieFromBank(%i)
  LOCAL %j
  PROC getBaddieBankIndex(%i) TO %j
  %j=% BANK e PEEK j
ENDPROC =%j
;
DEFPROC checkBaddie(%a,%x,%y)
  IF %y > $ff OR (x > $ff) THEN ENDPROC =%0
  IF %x=0 OR (y=240) THEN ENDPROC =%0
  PROC peekForXY(%x,%y) TO %f

  IF %f=0 OR (f=b) THEN ENDPROC =%0
  ; IF %b=1 THEN PRINT AT 3,0;"e:";%e;",b:";%b;",f:";%f;",offset:";%(32*(y/8))+(x/8);"<<"
  ; STOP


  IF %A[a+3] > 3 THEN %k=%@1100: ELSE %k=%@0011: ; > 3 = going left/right
  %A[a+3]=%A[a+3]^k: ; reverse the baddie direction
  IF %A[(j*6)+3] > 3 THEN %k=%@1100: ELSE %k=%@0011: ; > 3 = going left/right
  %A[(f*6)+3]=%A[(f*6)+3]^k: ; and do the same to the colliding baddie
ENDPROC =%1
;
DEFPROC baddieD(): ; baddie down
  PROC checkBaddie(%i,%A[i]-z,%A[i+1]) TO %f
  PROC clearBaddie(%b)

  IF %f THEN   %A[i+1]=%A[i+1]-z: ELSE  %A[i+1]=%A[i+1]+z
  IF %A[i+1] > 160 THEN %A[i+1]=160: ; edge
  %A[i+2]=11: ; sprite
  %A[i+5]=%A[i+5]^@1000: ;set sprite to up, and flip bits
  PROC setBaddie(%b)
ENDPROC
;
DEFPROC baddieU(): ; baddie up
  PROC checkBaddie(%i,%A[i]-z,%A[i+1]) TO %f
  PROC clearBaddie(%b)

  IF %f THEN %A[i+1]=%A[i+1]+z: ELSE %A[i+1]=%A[i+1]-z
  IF %A[i+1] > $ff THEN %A[i+1]=0
  %A[i+2]=10
  %A[i+5]=%A[i+5]^@1000: ;set sprite to up, and flip bits
  PROC setBaddie(%b)
ENDPROC
;
DEFPROC baddieL(): ; baddie left
  PROC checkBaddie(%i,%A[i]-z,%A[i+1]) TO %f
  PROC clearBaddie(%b)
  ;
  IF %f THEN %A[i]=%A[i]+z: ELSE %A[i]=%A[i]-z
  IF %A[i] > $ff THEN %A[i]=0
  ;
  %A[i+2]=%A[i+2]+1: IF %A[i+2] > 9 THEN %A[i+2]=8: ;animate sprite
  %A[i+5]=%A[i+5]&@0001: ; turn off all bits and leave bit 0 alone
  BANK %e POKE %(32*(A[i+1]/8))+(A[i]/8),%b
  PROC setBaddie(%b)
ENDPROC
;
DEFPROC baddieR(): ; baddie right
  PROC checkBaddie(%i,%A[i]+z,%A[i+1]) TO %f
  PROC clearBaddie(%b)
  ;
  IF %f THEN %A[i]=%A[i]-z: ELSE %A[i]=%A[i]+z
  IF %A[i] > 240 THEN %A[i]=240
  IF %A[i] > $ff THEN %A[i]=0
  ;
  %A[i+2]=%A[i+2]+1: IF %A[i+2] > 9 THEN %A[i+2]=8: ; animate sprite
  %A[i+5]=%(A[i+5]&1)+@1000: ; and flip bits %@1001
  PROC setBaddie(%b)
ENDPROC
;
DEFPROC takeLife()
  LET %l=%l-1
  FOR %i=0 TO 2
    SPRITE %11+i,%200+(i*16),%32,60,%i < l: ; draw lives
  NEXT %i
ENDPROC
;
DEFPROC up(): ; move up
  %P=2
  %y=%y-z
  %d=%d^@1000
  %s=34
ENDPROC
;
DEFPROC down(): ; move down
  %P=0
  %y=%y+z
  %d=%d^@1000
  %s=35
ENDPROC
;
DEFPROC left(): ; move left
  %P=4
  %x=%x-z
  %d=%@1001
  %s=%s+1: IF %s > 33 THEN %s=32
ENDPROC
;
DEFPROC right(): ; move right
  %P=6
  %x=%x+z
  %d=%@0001
  %s=%s+1: IF %s > 33 THEN %s=32
ENDPROC
;
; init functions
;
DEFPROC initSprites()
  LOAD "mummy.map" BANK 14: ; load tile map created at https://zx.remysharp.com/sprites/
  TILE 32,24: ; print tile for 16 tile cols by 12 tile rows
  LOAD "mummy.spr" BANK 16,0,4096
  SPRITE BANK 13
  SPRITE CLEAR : SPRITE PRINT 1
  ;
  ; footfall marks
  DATA 63,1,63,3,63,5,63,7
  DATA 0,63,2,63,4,63,6,63
  ; now we're going to push tiles into memory for feet
  FOR %i=%0 TO %7: READ %j: BANK %14 POKE %i,%j: NEXT %i
  FOR %i=%0 TO %7: READ %j: BANK %14 POKE %i+32,%j: NEXT %i
  RESTORE 10: ; reset the position of read for new games
  PAPER 255: INK 0: BORDER 6: ;background black (6 = yellow), text white
ENDPROC
;
DEFPROC xyToIndex(x,y)
ENDPROC =(32*y)+x
;
DEFPROC gameOver()
  INVERSE 1
  PRINT AT 4,7;"                 "
  PRINT AT 5,7;"                 "
  PRINT AT 6,7;"    GAME OVER    "
  PRINT AT 7,7;"                 "
  PRINT AT 8,7;"                 "
  INVERSE 0
  REPEAT : REPEAT UNTIL INKEY$ ="s":
ENDPROC
;
; initBaddies: %A=Array[[x,y,spr,angle(0: x, 1: y),direction(0: backward, 1: forward),alive]] (allowing for more than 10 baddies)
; note: i*j = j properties per baddie
DEFPROC initBaddies()
  LET %c=5: ; global badie count
  LET %j=6: ;n props
  FOR %i=1 TO %c: ;always have 9 baddie to update, to keep the rate constant
    LET %A[i*j]=% RND 192: ; 0 = x
    LET %A[(i*j)+1]=% RND 4*40: ; 1 = y
    LET %A[(i*j)+2]=8: ; 2 = SPRITE
    LET %A[(i*j)+3]=%1 << ( RND 2+2): ;3 = qaop/direction
    LET %A[(i*j)+4]=%$ff: ; 4 = alive
    LET %A[(i*j)+5]=1: ; 5 = sprite flags
    PROC setBaddie(%i)
  NEXT %i
ENDPROC
;
DEFPROC initTombs()
  FOR %i=0 TO 21: ; note that index 20 is used for dumping invalid/out of bounds
    LET %T(i)=%$f0: ; this is 11110000 - each edge is the high nibble and set as closed/waiting to be masked later
  NEXT %i
  PROC pickRandom()
  FOR %i=%0 TO %3
    %T(W(i))=%T(W(i))+i+1
  NEXT %i
ENDPROC
;
DEFPROC pickRandom()
  LOCAL %N: LOCAL %P: LOCAL %T
  %N=20: ; select from 0-20 (excluding 20)
  %P=4: ; pick 4 numbers
  %i=0
  ; init the 0-N array
  REPEAT
    %S(i)=%i
    %i=%i+1
  REPEAT UNTIL %i=N
  ; then go back downwards for P values
  REPEAT
    %T=% RND i
    %W(N-i)=%S(T)
    %i=%i-1
    %S(T)=%S(i)
  REPEAT UNTIL %i=(N-P)
  ; pickings are in global array W
ENDPROC
;
DEFPROC initOnce()
  CLS
  LAYER CLEAR
  SPRITE CLEAR
  ; LAYER OVER %@100
  LAYER 2,1
  LOAD "mummy.spr" BANK 13: ; load spritesheet
  TILE BANK 13: ; point tiles to spritesheet
  TILE DIM 14,0,32,8: ; using tile bank 14, offset 0, tile 32 wide, tile size 8
  %e=%15: ; game map bank
ENDPROC
;
DEFPROC initNewGame()
  ; define player and game state
  ; BANK %q ERASE 0,768,0
  LET %x=120: LET %y=0: LET %l=4: LET %s=32: ; s= SPRITE
  LET %d=1: LET %z=8: ; direction & speed
  LET %P=%$ffff: ; t=baddie speed, %P = last position
  LET %a=%$ffff
  LET %r=1
  PROC initSprites()
  PROC initBaddies()
  PROC initTombs()
  SPRITE STOP : ; switch to batching
  PROC takeLife()
ENDPROC
;
DEFPROC fps()
  LET %g=% DPEEK 23672
  LET %f=%g-h
  LET %h=%g
ENDPROC
;
DEFPROC cleanUp(e,l,s)
  ON ERROR
  LAYER CLEAR
  SPRITE CLEAR
  CLS
  BORDER 7
  PRINT 0,0;"Error:";e;", ";l;":";s
  PAUSE 0
ENDPROC
;
;Quick save
;
CLEAR : LAYER CLEAR : SPRITE PRINT 0: SAVE "mummy.bas" LINE 0
