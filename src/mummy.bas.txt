#program ohmummy
#autoline
#autostart
; Oh Mummy (clone), Remy Sharp 2020
RUN AT 2: REM 3.5Mhz (0 = 3.5, 1 = 7 (aim), 2 = 14 (likely))
;
PROC initSprites()
PROC initBaddies()
PROC initTombs()
; PROC fps()
; core loop
REPEAT
  PROC initNewGame(): ; setup new game
  REPEAT
    PROC updateLoop(): ; update logic and render
  REPEAT UNTIL %l=0: ; until zero lives
  PROC gameOver(): ; then print game over
REPEAT UNTIL 0: ; repeat forever
;
; start main game loop - we do only one thing at a time in the main loop
DEFPROC updateLoop()
  LET %b=0: ; baddie index
  REPEAT
    IF %b < 3 THEN PROC baddie(): SPRITE %b+1,%B(i),%B(i+1),%B(i+2),%B(i+5)
    LET %b=%b+1
  REPEAT UNTIL %b=3
  PROC updatePlayer():
  ; PROC fps(): PRINT AT 0,0;%f;" ";%x/16+(y/16);" ": ; f big = bad, small = good
  PROC treadMark()
  SPRITE MOVE INT
ENDPROC
;
DEFPROC updatePlayer()
  LET %j= IN 31: ; check the joystick and then keys
  ;
  IF %( IN $fbfe >> 0&1^1) THEN LET %j=%(j+@1000): ; Q
  IF %( IN $fdfe >> 0&1^1) THEN LET %j=%(j+@0100): ; A
  IF %( IN $dffe >> 1&1^1) THEN LET %j=%(j+@0010): ; O
  IF %( IN $dffe >> 0&1^1) THEN LET %j=%(j+@0001): ; P
  ;
  IF %j&$0f=0 THEN LET %P=%$ffff: ENDPROC : ; play isn't moving, early exit
  ; if I can't move on x plane, check y
  IF %(x-32) MOD 48 THEN : ELSE : IF %j&@0100 THEN PROC down(): ELSE IF %j&@1000 THEN PROC up()
  ;
  PROC checkTomb(): ; check before we potentially move again
  ;
  IF %(y-48) MOD 40 THEN : ELSE : IF %j&@0010 THEN PROC left(): ELSE IF %j&@0001 THEN PROC right():
  ;
  ; check for map edge TODO only check if value changed
  IF %x < 32 THEN : LET %x=32: ELSE IF %x > 272 THEN : LET %x=272
  IF %y < 48 THEN : LET %y=48: ELSE IF %y > 208 THEN : LET %y=208
  ;
  PROC checkTomb()
  ;
  SPRITE 10,%x,%y,%s,%d
ENDPROC
;
DEFPROC checkTomb()
  IF %(x-32 MOD 48) OR (y-48 MOD 40) THEN ENDPROC : ; only run on corners
  LET %e=%(6*((y-48)/40))+((x-32)/48): ; x/y as aisle index
  IF %e=a THEN ENDPROC : ; we were just there (%a is last position)
  ;
  %f=%e-a: ; f is forward +1 or backward -1
  %k=% ABS SGN {f}=1: ; k tracks the axis, +1 for X, 0 for Y
  ;
  IF % SGN {f < 0} THEN %g=%a: ELSE %g=%e
  IF %k THEN PROC getXTombs() TO %g,%h: ELSE PROC getYTombs() TO %g,%h
  IF %g > 20 THEN %g=20: ; assign out of bounds to the junk element (index 20)
  IF %h > 20 THEN %h=20
  ; bitwise op below is $current wall & (0xF0 + wall, 1 top, 2 right, 4 bottom, 8 left)
  ; importantly this leaves the first 4 bits untouched
  IF %k THEN %T[g]=%T[g]&@11111101:%T[h]=%T[h]&@11110111: ELSE %T[g]=%T[g]&@11111011:%T[h]=%T[h]&@11111110
  IF %T[g]=0 THEN PROC openTomb(%g):%T[g]=%$f0: ; if tomb above is unlocked (0x00) then open and set to 0xF0 (locked)
  IF %T[h]=0 THEN PROC openTomb(%h):%T[h]=%$f0: ; if tomb below is unlocked
  ;
  LET %a=%e: ; save the last position
ENDPROC
;
DEFPROC getXTombs(): ; uses scoped %g var from checkTomb
  %h=%1+(g/6)
  %i=%g-h
ENDPROC =%i-5,%i
;
DEFPROC getYTombs(): ; uses scoped %g var from checkTomb
  %i=%g-6-(g/6)
ENDPROC =%i,%i+1
;
DEFPROC openTomb(%i)
  IF %i=20 THEN ENDPROC
  ON ERROR PRINT AT 0,0;%i;": ";%i MOD 5;": ";%16+((i MOD 5)*48);"/";%32+((i/4)*40);"     ": ENDPROC
  LAYER ERASE %16+((i MOD 5)*48),%32+((i/5)*40),32,24,28: ; green fill 28
ENDPROC
;
; leave tread marks
DEFPROC treadMark(): ;up=0,down=1,left=2,right=3
  IF %P=$ffff THEN ENDPROC : ; didn't move
  IF %P=2 THEN LET %i=%1: ELSE LET %i=%0: ; if left +1, right = -1
  IF %P=0 THEN LET %j=%1: ELSE LET %j=%0
  BANK 14 POKE 0,%P
  TILE 1,1 AT 0,0 TO %x/16+i-2,%y/16+j-2
ENDPROC
;
; handle baddies
;
DEFPROC baddie()
  LET %i=%b*6: ; 6 props (easy to mess this up!)
  ;
  IF %B(i+4)=0 THEN ENDPROC : ; this baddie is dead
  ; else (baddie is alive) and baddie is over player sprite (spr 10): kill baddie, turn off sprite (5), take life and bail
  IF % SPRITE OVER (b+1,10,3,3) THEN LET %B(i+4)=0: LET %B(i+5)=0: PROC takeLife(): ENDPROC
  ;
  LET %j=%B(i+3)
  IF %j=1 THEN PROC baddieD(): IF %B(i+1)-48 MOD 40 THEN ENDPROC : ;down
  IF %j=2 THEN PROC baddieU(): IF %B(i+1)-48 MOD 40 THEN ENDPROC : ;up
  IF %j=4 THEN PROC baddieL(): IF %B(i)-32 MOD 48 THEN ENDPROC : ;left
  IF %j=8 THEN PROC baddieR(): IF %B(i)-32 MOD 48 THEN ENDPROC : ;right
  ;
  ; rotate 1:3 times
  IF % RND 3=0 THEN LET %B(i+3)=%1 << RND 4: ;qaop/direction
ENDPROC
;
DEFPROC baddieD(): ; baddie down
  %B(i+1)=%B(i+1)+z
  IF %B(i+1) > 208 THEN :%B(i+1)=208: ;
  %B(i+2)=55:%B(i+5)=%B(i+5)^@1000: ;set sprite to up, and flip bits
ENDPROC
;
DEFPROC baddieU(): ; baddie up
  %B(i+1)=%B(i+1)-z
  IF %B(i+1) < 48 THEN :%B(i+1)=48
  %B(i+2)=54:%B(i+5)=%B(i+5)^@1000: ;set sprite to up, and flip bits
ENDPROC
;
DEFPROC baddieL(): ; baddie left
  %B(i)=%B(i)-z
  IF %B(i) < 32 THEN :%B(i)=32:
  %B(i+2)=%B(i+2)+1: IF %B(i+2) > 53 THEN %B(i+2)=52: ;animate sprite
  %B(i+5)=%@0001: ; and flip bits
ENDPROC
;
DEFPROC baddieR(): ; baddie right
  %B(i)=%B(i)+z
  IF %B(i) > 272 THEN :%B(i)=272
  %B(i+2)=%B(i+2)+1: IF %B(i+2) > 53 THEN %B(i+2)=52: ; animate sprite
  %B(i+5)=%@1001: ; and flip bits
ENDPROC
;
DEFPROC takeLife()
  LET %l=%l-1
  FOR %i=0 TO 2
    SPRITE %11+i,%200+(i*16),%32,9,%i < l: ; draw lives
  NEXT %i
ENDPROC
;
DEFPROC up(): ; move up
  %P=0
  %y=%y-z
  %d=%d^@1000
  %s=58
ENDPROC
;
DEFPROC down(): ; move down
  %P=1
  %y=%y+z
  %d=%d^@1000
  %s=59
ENDPROC
;
DEFPROC left(): ; move left
  %P=2
  %x=%x-z
  %d=%@1001
  %s=%s+1: IF %s > 57 THEN %s=56
ENDPROC
;
DEFPROC right(): ; move right
  %P=3
  %x=%x+z
  %d=%@0001
  %s=%s+1: IF %s > 57 THEN %s=56
ENDPROC
;
; init functions
;
DEFPROC initSprites()
  LAYER 2,1: CLS
  LOAD "mummy.spr" BANK 13: ; load spritesheet
  LOAD "mummy.map" BANK 14: ; load tile map created at https://zx.remysharp.com/sprites/
  TILE BANK 13: ; point tiles to spritesheet
  TILE DIM 14,0,16,16: ; bank 14, offset 0, tilemap width 16 tiles, tile size 16
  TILE 16,12: ; print tile for 16 tile cols by 12 tile rows
  LOAD "mummy.spr" BANK 16,0,4096
  SPRITE BANK 13
  SPRITE CLEAR : SPRITE PRINT 1
  PAPER 255: INK 0: BORDER 6: ;background black (6 = yellow), text white
ENDPROC
;
DEFPROC gameOver()
  INVERSE 1: PRINT AT 6,11;"GAME OVER"
  REPEAT : REPEAT UNTIL INKEY$ ="s": INVERSE 1
ENDPROC
;
; initBaddies: %B=Array([x,y,spr,angle(0: x, 1: y),direction(0: backward, 1: forward),alive])
; note: i*j = j properties per baddie
DEFPROC initBaddies()
  LET %j=6: ;n props
  FOR %i=0 TO 2: ;total baddies
    LET %B(i*j)=% RND 192+48: ; 0 = x
    LET %B((i*j)+1)=% RND 4*48+48: ; 1 = y
    LET %B((i*j)+2)=53: ; 2 = SPRITE
    LET %B((i*j)+3)=%1 << ( RND 2+2): ;3 = qaop/direction
    LET %B((i*j)+4)=1: ; 4 = alive
    LET %B((i*j)+5)=1: ; 5 = sprite flags
  NEXT %i
ENDPROC
;
DEFPROC initTombs()
  FOR %i=0 TO 21: ; note that index 20 is used for dumping invalid/out of bounds
    LET %T(i)=%$0f: ; this is 00001111 - each edge will be bit masked, and once it hits 0, it's masked with 0xf0 so it's never 0 again
  NEXT %i
ENDPROC
;
DEFPROC initNewGame()
  ; define player and game state
  LET %x=144: LET %y=32: LET %l=4: LET %s=56: ; s= SPRITE
  LET %d=1: LET %z=8: ; direction & speed
  LET %P=%$ffff: ; t=baddie speed, %P = last position
  LET %a=%$ffff
  LET ctr=0
  SPRITE STOP : ; switch to batching
  SPRITE 10,%x,%y,%s,%d
  PROC takeLife()
ENDPROC
;
DEFPROC fps()
  LET %g=% DPEEK 23672
  LET %f=%g-h
  LET %h=%g
ENDPROC
;
;Quick save
;
CLEAR : LAYER CLEAR : SPRITE PRINT 0: SAVE "mummy.bas" LINE 0
