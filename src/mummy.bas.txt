#program mummy
#autostart 10
#autoline 10
; Oh Mummy (clone), Remy Sharp 2020 / @rem
;
RUN AT 3: REM @ 28Mhz
;
; ************ TODO ***************
; - [ ] (bug) on start of next level you're thrown out of the beginning
; - [ ] (req) Hi-score(?)
; - [ ] (bug) You ded doesn't draw over sprites
; - [ ] (feat) Can I colour the border?
; - [ ] (feat) "Get outta there" / "now find the archaeologist" / "find that key!" marquee
; - [ ] (feat) AI for baddie & dumb baddies
; - [ ] (feat) Improve background tile/walkway image
; - [~] Welcome screen / start game
; - [x] (req) Game over - Win state
; - [x] (feat) Change colours of tombs between each level
; - [x] (feat) When player tries to turn 1 step away from a turn, "help" them and jump over it
; - [x] (bug) baddies are faster than player (rendering is simpler) (5: baddie slow, 4: baddie same speed)
; - [x] (feat) Crack effect on tomb edge
; - [x] (perf) Don't call new round of poke on each level
; - [x] (bug) Fix the top left corner foot steps
; - [x] (perf) Can we make screen transitions faster (tried different methods, prob not)
; - [x] Fix tomb 9 affecting tomb 10
; - [x] Fix baddie reveal - and the direction they go
; - [x] Baddie revealed
; - [x] Score
; - [x] 10 treasure chests
; - [x] Open tomb effect (spr@8-11 + 12 transparency)
; - [x] Level up
; - [x] Graphics for prize tombs
; - [x] Possibly allow player in start position?
;
; ******** VARIABLE INDEX *********
;
; %a = player last corner, used for tomb calc - initilised to $FF
; %A[] = baddie array (allows for > 64 elements)
; %b = baddie index
; %c = baddie count
; %C[] = palette colours for tombs
; %d = player sprite flags (mirror, etc)
; %n = delta time counter (only used during dev, but needs to be reserved)
; %l = player lives
; %P = player last position, used for tread marks - initilised to $FFFF
; %q = player last direction (whilst movement is engaged) - used for movement hacks
; %r = (flag) player has scroll and can kill a mummy
; %s = player sprite
; %R() = used to pick random selection of hidden items
; %S(...) = speed option array
; %T(21) = tomb array 0-19 with index 20 used for temp rendering, with 8bit flags (14 items contain data in the low bit)
; %t = items to find - defaults to 2
; %w = score
; %x = player x
; %y = player y
; %z = speed (for both baddie and player) - calculated based on DIFFICULTY
; --- non int vars ---
; DIFFICULTY(3) = how many lives you start with
; LEVEL(1) = current level
; SPEED(3) = how fast the baddies are
; PLAYING = bool like - whether we're in game or not (in menus)
;
; TMP VARIABLES
; i, j, k (but often shared) - then - e, f, g, h, m, o, q, u, v (unless documented, are disposable between DEFPROCS)
;
; BANK INDEX
;
; 19: tiles (copied from BANK 23)
; 20: music (mummy.ndr)
; 21: music player (nextdaw.drv)
; 22: main player and NPC sprites (m-sprites.spr)
; 23: tile map (used with BANK 19) (mummy.map)
; 24: tile data (sprites) (m-tiles.spr)
; 25: "oh mummy" layer 2 header (1/3 of layer 2) (banner.bin)
; 26: info screen tokens (tokens.map)
; 27: tomb tiles - extra graphics arranged in a useful layout
; 28: palette - let's me change level colours without additional graphics
;
; **********************************
;
;PROC dT()
;PROC splash()

DEBUG=0
SPRITEON=1

ON ERROR PROC exit()
PROC initOnce()
PROC initNewGame()
PROC mainLoop()

; game loop - includes: render loop, lives check & game over
DEFPROC mainLoop()
  REPEAT
    REPEAT
      ;IF DEBUG THEN IF INKEY$ ="s" THEN SPRITEON= NOT SPRITEON: SPRITE PRINT SPRITEON
      ;IF DEBUG THEN PRINT AT %1,%0;"mem=";%65536- USR 7962;" ": ; memory available....
      IF DEBUG THEN IF INKEY$ ="t" THEN %t=0: ; FIXME remove TESTING ONLY
      PROC updateLoop(): ; update logic and render
    REPEAT UNTIL %l=0 OR (t=0): ; until zero lives
    IF %t=0 THEN PROC nextLevel(LEVEL+1): ELSE PROC gameOver(): PROC initNewGame()
  REPEAT UNTIL 0: ; repeat forever
ENDPROC
;
; start main game loop - we do only one thing at a time in the main loop
DEFPROC updateLoop()
  PROC updatePlayer(%8)
  LET %b=1: ; baddie loop
  REPEAT
    %i=%b*6: ; 6 props (easy to mess this up!)
    IF % SPRITE CONTINUE b < 2 THEN PROC updateBaddie()
    LET %b=%b+1
  REPEAT UNTIL %b=(c+1)
  SPRITE MOVE INT
  ;PROC dT() TO %f: PRINT AT 0,0;%c;"@";%f;" ": ; f big = bad, small = good
ENDPROC
;
DEFPROC updatePlayer(%z)
  PROC treadMark(): ; put treadmarks on the place we're about to move away from

  LET %j= IN 31: ; check the joystick and then keys

  ; NOTE: these shifts aren't always needed, but it makes the code consistent
  IF %( IN $fbfe >> 0&1^1) THEN LET %j=%j+@1000: ; Q
  IF %( IN $fdfe >> 0&1^1) THEN LET %j=%j+@0100: ; A
  IF %( IN $dffe >> 1&1^1) THEN LET %j=%j+@0010: ; O
  IF %( IN $dffe >> 0&1^1) THEN LET %j=%j+@0001: ; P

  ; NOTE I no longer do an early exit - this keeps the game speed constant, otherwise the baddies speed up
  ; IF %j&$0f=0 THEN LET %P=%$ffff: ENDPROC : ; play isn't moving, early exit
  IF %j THEN IF %y MOD 40 OR (y > $ff) THEN IF %(j&@0011)=j THEN %j=%j+q: ; add the y direction
  IF %j THEN IF %x MOD 48 THEN IF %(j&@1100)=j THEN %j=%j+q: ; add the x direction

  ; the last direction is stored in the up/down/left/right routines

  ; If I can't move on the x plane,checky
  IF %x MOD 48 THEN : ELSE : IF %j&@0100 THEN PROC down(%z): ELSE IF %y > 0 AND (j&@1000) THEN PROC up(%z)

  PROC checkTomb(): ; %P = $ffff if they haven't moved

  IF %y MOD 40 OR (y > $ff) THEN : ELSE : IF %j&@0010 THEN PROC left(%z): ELSE IF %j&@0001 THEN PROC right(%z)

  ; note that %x > $ff means the integer has gone from 0, to -1, but it's unsigned
  ; so it'll be up in the 65K range, so this check against 255 is good enough
  IF %x > $ff THEN : LET %x=0: ELSE IF %x > 240 THEN : LET %x=240

  IF %t=1 THEN IF %j&@1000 AND (y=0) AND (x=96) THEN PROC up(%z):%t=0: SPRITE 64,%x+32,%y+48,%s,%d: ENDPROC
  IF %y=$FFF0 OR (y=$FFF8) THEN : ELSE : IF %y > $ff THEN : LET %y=0: ELSE IF %y > 160 THEN : LET %y=160

  ; render
  SPRITE 64,%x+32,%y+48,%s,%d

  ; check the 2nd tomb _after_ sprite render to help smooth out the movement
  PROC checkTomb()

  ; check if we're bumping into a baddie
  %i=% SPRITE OVER (64,1 TO c)
  IF %i=0 THEN ENDPROC
  SPRITE %i,,,,0
  %i=%i*6
  IF %A[i+4]=0 THEN ENDPROC : ; ignore hidden zombies/inactive baddies
  %A[i+4]=0
  %A[i+5]=0
  IF %r=0 THEN PROC takeLife(): ELSE %r=0
ENDPROC
;
DEFPROC checkTomb()
  ; IIRC the PAUSE 1 is to attempt to match the timing if the player _had_ openned a tomb
  IF %(x MOD 48) OR (y MOD 40) THEN PAUSE 1: ENDPROC : ; only run on corners
  LET %i=%(6*(y/40))+(x/48): ; x/y as aisle index (6 aisles for 5 rows of tombs)
  IF %i=a THEN PAUSE 1: ENDPROC : ; we were just there (%a is last position)
  IF %a=$ffff THEN %a=%i: PAUSE 1: ENDPROC

  %f=%i-a: ; f is forward +1 or backward -1
  %k=% ABS SGN {f}=1: ; k tracks the axis, +1 for X, 0 for Y

  ; important: %g is assigned here and used within getXTombs and getYTombs
  IF % SGN {f < 0} THEN %g=%a: ELSE %g=%i

  IF %k THEN PROC getXTombs() TO %g,%h: ELSE PROC getYTombs() TO %g,%h

  ; note that index 20 is out of bounds and assigns to the junk element
  IF %g < 20 THEN PROC crackEdge(%k,%g,%T(g),1,%@11011111,%@10111111)
  IF %h < 20 THEN PROC crackEdge(%k,%h,%T(h),0,%@01111111,%@11101111)

  %a=%f+a: ; save the last position (reverting from %f we lost %i)
ENDPROC
;
; getXTombs: get tombs above and below of player
DEFPROC getXTombs()
  ; %g from checkTomb
  %h=%1+(g/6)
  %i=%g-h
ENDPROC =%i-5,%i
;
; getYTombs: get tombs on the left and right of player
DEFPROC getYTombs()
  ;%g from checkTomb

  ; this uses special logic for the left and right edge of the grid,
  ; otherwise when you complete tomb 4 (x:4, y:0) then it wrongly
  ; applies a completed edge to 5 (x:0, y:1). The logic below fixes
  ; that - and returns '21' for a non existant/out of scope tomb
  %v=%(g+1) MOD 6
  IF %v > 1 THEN %i=%g-6-(g/6): ENDPROC =%i,%i+1: ; inner grid
  IF %v=1 THEN %i=%g-6-(g/6): ENDPROC =21,%i+1: ; completed on right edge
ENDPROC =%g-6-(g/6),21: ; case 0 = completed on left edge
;
DEFPROC crackEdge(%k,%i,%j,%o,%a,%b)
  ; cache the curent value, and if it doesn't change, nothing to do / endproc
  IF %j&8=8 THEN ENDPROC

  %u=%2+((i MOD 5)*6): ; map X to the x coord in tile offset
  %v=%4+((i/5)*5): ; same with Y

  ; bitwise op below is $current wall & (0xF0 + wall, 1 top, 2 right, 4 bottom, 8 left)
  ; importantly this leaves the first 4 bits untouched (Least Significant Nibble) meaning: @00001111
  IF %k THEN %T(i)=%T(i)&a: ELSE %T(i)=%T(i)&b
  IF %T(i)=j THEN ENDPROC

  ; print the cracked tile
  IF %k THEN TILE 4,1 AT 0,%24+o TO %u,%v+(o*2): ELSE TILE 1,3 AT %0+o,%21 TO %u+(o*3),%v

  %j=%T(i)

  ; only continue if the tomb is fully open
  IF %j&$f8 <> 0 THEN ENDPROC

  ; open tomb (ie. slightly different colour)
  TILE 4,3 AT 0,3 TO %u,%v

  ; early exit
  ;IF %j=0 THEN %T(i)=%j+8: ENDPROC

  TILE 4,3 AT 0,%(3*j)+3 TO %u,%v

  ; archaeologist(1), key(2), amulet(3), baddie(4) or treasure(5)
  IF %j=1 THEN %t=%t-1:%w=%w+50: ELSE IF %j=2 THEN %t=%t-1: ELSE IF %j=3 THEN %r=%1: ELSE IF %j=5 THEN %w=%w+5

  ; if we revealed a baddie, bring them to life, and kick them off
  IF %j=4 THEN %A[6+4]=%$ff:%A[6+3]=3: SPRITE 1,,,%A[6+5]-4,1: SPRITE CONTINUE 1, STOP ,%A[7] TO %A[7]+16 STEP 1 RUN ,%A[6+5]-4 TO %A[6+5]-1, BIN 10,1,20

  %T(i)=%j+8: ; prevent the tomb from being reopened

  PROC printScore()
ENDPROC
;
; leave tread marks
DEFPROC treadMark(): ;down=0,up=2,left=4,right=6
  IF %P=$ffff THEN ENDPROC : ; didn't move
  IF %P > 3 THEN %i=%(x >> 3) MOD 2: ELSE %i=%(y >> 3) MOD 2: ; if left +1, right = -1
  ;
  %v=%(y >> 3)+2
  IF %v > 8000 THEN %v=%v MOD 8192: ; handle when player is in start position

  ; IF %P=0 THEN TILE 2,1 AT 0,%26+i TO %x >> 3,%v
  ; IF %P=2 THEN TILE 2,1 AT 2,%26+i TO %x >> 3,%v+1
  ; IF %P=4 THEN TILE 1,2 AT %0+i,28 TO %x >> 3+1,%v
  ; IF %P=6 THEN TILE 1,2 AT %2+i,28 TO %x >> 3,%v
  ; The four above lines can be refactored into a single line below
  IF %P < 3 THEN TILE 2,1 AT %P,%26+i TO %x >> 3,%v+(P >> 1): ELSE TILE 1,2 AT %P-4+i,28 TO %x >> 3+(P MOD 3),%v

  %P=%$ffff: ; now we're not moving
ENDPROC
;
; handle baddies
;
DEFPROC updateBaddie()
  ; if this baddie is dead, fast exit
  IF %A[i+4]=0 THEN ENDPROC

  %f=% SPRITE AT (b,0): ; x
  %g=% SPRITE AT (b,1): ; y

  ; select a random direction 0-3 is valid, but if we have a random value higher
  ; then decide whether the baddie should chase the goodie, or keep going in the
  ; current direction
  %j=% RND 12
  IF %j > 3 THEN %j=%A[i+3]

  ; if they're on the edge of the map, don't let them walk off
  IF %g=208 THEN IF %j=0 THEN %j=1
  IF %g=48 THEN IF %j=1 THEN %j=0
  IF %f=272 THEN IF %j=2 THEN %j=3
  IF %f=32 THEN IF %j=3 THEN %j=2

  ; save their direction
  %A[i+3]=%j

  ; FIXME what does this do?
  %A[(i*j)+2]=0

  ; this handles an edge case whereby the baddie is being revealed from hiding
  ; and they're not on the right Y plane, so the distance to the next intersection is adjusted
  %v=%48
  IF %(f-32) MOD 48 <> 0 THEN %v=%32: IF %j < 2 THEN %j=2

  ; Note: I don't make use of the sprite mirror flag, instead I'm storing all the permutations of the sprite
  ; because I have room, and it means that I don't need an IF and subsequent SPRITE statement, i.e. the
  ; fastest code is no code.
  %e=%A[i+5]
  IF %j=0 THEN SPRITE CONTINUE %b, STOP ,%g TO %g+40 STEP %z RUN ,%e-4 TO %e-3, BIN 10,0,0: ENDPROC : ; down
  IF %j=1 THEN SPRITE CONTINUE %b, STOP ,%g-40 TO %g STEP % SGN {-z} RUN ,%e-2 TO %e-1, BIN 10,0,0: ENDPROC : ; up
  IF %j=2 THEN SPRITE CONTINUE %b,%f TO %f+v STEP %z RUN , STOP ,%e TO %e+1, BIN 10,0,0: ENDPROC : ; right
  IF %j=3 THEN SPRITE CONTINUE %b,%f-v TO %f STEP % SGN {-z} RUN , STOP ,%e+2 TO %e+3, BIN 10,0,0: ENDPROC : ; left
ENDPROC
;
DEFPROC takeLife()
  %l=%l-1
  FOR %i=1 TO %l
    SPRITE %50+i,%16,%32+(i*14),54,1
  NEXT %i
  FOR %i=%l+1 TO % INT {DIFFICULTY}
    SPRITE %50+i,%16,%32+(i*14),55,1
  NEXT %i
ENDPROC
;
DEFPROC up(%z): ; move up
  %q=8
  %P=2
  %y=%y-z
  %d=%d^@1000
  %s=50
ENDPROC
;
DEFPROC down(%z): ; move down
  %q=4
  %P=0
  %y=%y+z
  %d=%d^@1000
  %s=51
ENDPROC
;
DEFPROC left(%z): ; move left
  %q=2
  %P=4
  %x=%x-z
  %d=%@1001
  %s=%s+1: IF %s > 49 THEN %s=48
ENDPROC
;
DEFPROC right(%z): ; move right
  %q=1
  %P=6
  %x=%x+z
  %d=%@0001
  %s=%s+1: IF %s > 49 THEN %s=48
ENDPROC
;
DEFPROC pad(%w)
  IF %w < 10 THEN ENDPROC ="000"
  IF %w < 100 THEN ENDPROC ="00"
  IF %w < 1000 THEN ENDPROC ="0"
ENDPROC =""
;
DEFPROC printScore()
  w$=""
  IF %w < 1001 THEN PROC pad(%w) TO w$
  PRINT AT 0,0;"Score ";w$;%w
ENDPROC
;
; init functions
;
DEFPROC initSprites()
  SPRITE CLEAR : LAYER 2,1: SPRITE BORDER 1: SPRITE PRINT 1
  BANK 19 CLEAR
  BANK 23 COPY TO 19: ; reset the map
  TILE DIM 19,0,32,8: ; using tile bank 19, offset 0, tile 32 wide, tile size 8
  TILE 32,24: ; print tile for 14 tile cols by 12 tile rows
  TILE DIM 27,0,4,8: ; swap to our tomb tile set
  SPRITE STOP : ; switch to batching (though pretty sure this isn't required)

  PROC setBorder(%$168-C( INT {LEVEL}))
  LAYER 2,1: ; re-select our original layer
  PAPER 0: INK 236
ENDPROC
;
DEFPROC setBorder(%n)
  LAYER 1,0: PALETTE DIM 9
  BANK 28 DPOKE %(512+32),%((n&1) << 8)+(n >> 1): ; poke 16bit little endian next colour
  BORDER 0
  LAYER PALETTE 0 BANK 28,512
ENDPROC
;
DEFPROC gameOver()
  PAPER 0: INK 255
  ; FIXME this should be done with a layer erase
  ; cheap black out
  PRINT AT 7,7;"                  "
  PRINT AT 8,7;"                  "
  PRINT AT 9,7;"                  "
  PRINT AT 10,7;"                  "
  PRINT AT 11,7;"                  "
  PRINT AT 12,7;"                  "
  PRINT AT 13,7;"                  "
  PRINT AT 14,7;"                  "
  PRINT AT 15,7;"                  "
  PRINT AT 16,7;"                  "
  FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  PRINT AT 12,8;"G": FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  PRINT AT 12,10;"A": FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  PRINT AT 12,12;"M": FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  PRINT AT 12,14;"E": FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  PRINT AT 12,17;"O": FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  PRINT AT 12,19;"V": FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  PRINT AT 12,21;"E": FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  PRINT AT 12,23;"R": FOR %i=%0 TO %20: PAUSE 1: NEXT %i
  INK 224
  PRINT AT 15,7;"     you ded      "
  REPEAT : REPEAT UNTIL INKEY$ <> "" OR IN 31=16:
  SPRITE CLEAR
ENDPROC
;
; initBaddies: %A=Array[[x,y,spr,angle(0: x, 1: y),direction(0: backward, 1: forward),alive]] (allowing for more than 10 baddies)
; note: i*j = j properties per baddie
DEFPROC initBaddies()
  LET %j=6: ;n props
  FOR %i=1 TO %c
    LET %A[i*j]=%( RND 6)*48: ; 0 = x
    LET %A[(i*j)+1]=%40+( RND 4*40): ; 1 = y - baddies start on bottom 3 rungs
    LET %A[(i*j)+2]=0: ; 2 = delay (used to be SPRITE)
    LET %A[(i*j)+3]=% RND 4: ;3 = qaop/direction
    ; if we're on the last baddie, then we'll set them to dead, but they'll come to life later
    IF %i=1 THEN %A[(i*j)+4]=%$0: ELSE %A[(i*j)+4]=%$ff: ; 4 = alive (note to self: I changed this to 1 and baddie walked backwards)
    LET %A[(i*j)+5]=%44-(8*(c-i)): ; 5 = sprite offset (for baddie type)
    SPRITE %i,%A[i*j]+32,%A[(i*j)+1]+48,%A[(i*j)+5],%1&A[(i*j)+4]
  NEXT %i
ENDPROC
;
DEFPROC initTombs()
  FOR %i=0 TO 20: ; note that index 20 is used for dumping invalid/out of bounds
    LET %T(i)=%$f0: ; this is 11110000 - each edge is the high nibble and set as closed/waiting to be masked later
  NEXT %i
  PROC pickRandom()

  ; %W(3)=%4 :; use to force hidden baddie position

  ; generates: scroll (0), archaeologist (1), key (2), hidden mummy/baddie (3)
  FOR %i=%0 TO %3
    %T(W(i))=%T(W(i))+(i+1)
  NEXT %i

  ; PRINT AT 22,0;"Hidden @ ";%W(3)

  ; hides the baddie in a tomb
  %A[6]=%(W(3) MOD 5)*48+32+32
  %A[7]=%(W(3)/5)*40+24+48
  SPRITE 1,%A[6],%A[7],,,
  ;
  ; treasures x 5
  FOR %i=%4 TO %9
    %T(W(i))=%T(W(i))+5
  NEXT %i
ENDPROC
;
DEFPROC pickRandom()
  LOCAL %n: LOCAL %p: LOCAL %t
  %v=20: ; select from 0-20 (excluding 20)
  %p=14: ; pick 4 numbers
  %i=0
  ; init the 0-N array
  REPEAT
    %R(i)=%i
    %i=%i+1
  REPEAT UNTIL %i=v
  ; then go back downwards for P values
  REPEAT
    %t=% RND i
    %W(v-i)=%R(t): ; W is our global (winning positions)
    %i=%i-1
    %R(t)=%R(i)
  REPEAT UNTIL %i=(v-p)
  ; pickings are in global array W
ENDPROC
;
DEFPROC loadAssets()
  LAYER CLEAR
  LAYER 2,1
  PAPER 252: INK 0: BORDER 0:
  SPRITE CLEAR
  ; allows for stop and start when music is running still
  ON ERROR CONTINUE : DRIVER 50,4: ON ERROR
  ON ERROR CONTINUE :.uninstall "assets/nextdaw.drv" : ON ERROR
  .install "assets/nextdaw.drv"
  LOAD "assets/mummy.ndr" BANK 20: ; plus bank 21 for music
  LOAD "assets/m-sprites.spr" BANK 22: SPRITE BANK 22
  LOAD "assets/mummy.map" BANK 23: ;load tile map created at https://zx.remysharp.com/sprites/
  LOAD "assets/m-tiles.spr" BANK 24: TILE BANK 24: ; load spritesheet for tiles
  LOAD "assets/banner.bin" BANK 25: ; header for non-game screens
  LOAD "assets/tokens.map" BANK 26
  LOAD "assets/tombs.map" BANK 27
  LOAD "assets/mummy.pal" BANK 28
  LOAD "assets/font.bin" CODE 64000
ENDPROC
;
DEFPROC initOnce()
  PROC loadAssets(): ; separate load allows for future single tape loader

  PLAYING=0
  DIFFICULTY=3
  SPEED=3

  %S(1)=%12
  %S(2)=%10
  %S(3)=%8
  %S(4)=%6
  %S(5)=%4

  %C(1)=%0
  %C(2)=%16
  %C(3)=%236
  %C(4)=%50
  %C(5)=%128

  MUSIC= NOT DEBUG

  ; music
  DRIVER 50,1,0,20: ; BANK21
  DRIVER 50,1,1,21: ; BANK21
  DRIVER 50,2: ; Init Song
  IF MUSIC THEN DRIVER 50,3: ; Play Song

  ; font
  DPOKE 23606,63744: ; 64000-256
  LAYER 2,1
  PRINT CHR$ 2: ; trigger the font to be loaded
  ; reduce the font into 7x8 (bit more space to write)
  PRINT CHR$ 30; CHR$ 7; CHR$ 31; CHR$ 7

  ; colour palette
  PALETTE DIM 9
  LAYER PALETTE 0 BANK 28,0
  LAYER PALETTE 0

  POKE 23658,0: ; turn off CAPS LOCK (for menu items)
ENDPROC
;
DEFPROC initGameVars()
  LET %x=96: LET %y=-16: LET %s=51: ; s=sprite
  LET %d=1: ; direction & speed
  LET %P=%0: ; %P = last player position
  LET %a=%$ffff
  LET %r=%0: ; can player kill a mummy?
  LET %t=%3
ENDPROC
;
DEFPROC youWin()
  LEVEL=1

  SPRITE PRINT 0
  PROC header()

  LET %y=6

  PRINT AT 0,0; CHR$ 30; CHR$ 7; CHR$ 31; CHR$ 7

  PRINT AT %y-1,12; CHR$ 29; CHR$ 1;"YOU DID IT!!!"; CHR$ 29; CHR$ 0
  PRINT AT %y+2,1;"You saved all five of the "
  PRINT AT %y+3,1;"archaeologists. They're safe back"
  PRINT AT %y+4,1;"home drinking tea and dunking"
  PRINT AT %y+5,1;"biscuits. Great work!"

  PRINT AT %y+8,1;"But...a hero's work is never done."
  PRINT AT %y+9,1;"More archaeologists have gone"
  PRINT AT %y+10,1;"walkies, and they need your help."
  PRINT AT %y+12,1;"Will you survive the challenge?"

  PAPER 0: INK 252
  PRINT AT %y+14,17;"Onward adventurer!"
  PAPER 252: INK 0

  REPEAT : REPEAT UNTIL INKEY$ =""
  REPEAT : REPEAT UNTIL INKEY$ <> ""
ENDPROC
;
DEFPROC initNewGame()
  %w=0: ; score
  ; define player and game state
  LET %z=%S( INT {SPEED}): ; baddie speed
  LET %c=1: ; global badie count
  LET %l=% INT {DIFFICULTY}: ; lives
  PROC welcome()
  ;
  PLAYING=1
  PROC nextLevel(1)
ENDPROC
;
DEFPROC nextLevel(l)
  RANDOMIZE 0
  LEVEL=l
  IF LEVEL=6 THEN PROC youWin()

  %j=% INT {LEVEL}


  %c=%j+1: ; baddies increase with each level


  ; 0x150, 0x1f8, 0x1e8, 0x168
  ; offset values:
  ; yellow (0), orange (16), purple (236), ice blue (50), green (128)
  %i=%C(j):
  LAYER PALETTE 0,33,%$150-i
  LAYER PALETTE 0,34,%$1f8-i
  LAYER PALETTE 0,35,%$1e8-i
  LAYER PALETTE 0,36,%$168-i

  PROC initSprites()
  PROC initBaddies()
  PROC initTombs()
  PROC initGameVars()
  PROC treadMark(): ; depends on player position
  %l=%l+1: ; stupid, but can't be bothered to add more code
  PROC takeLife(): ; renders the lives

  %w=%w+ INT {(LEVEL-1)*50}

  PROC printScore()

  ; show how many archaeologist's are left to save
  FOR %i=2 TO LEVEL
    SPRITE %55+i,%290,%14+(i*18),52,1
  NEXT %i
  FOR %i=LEVEL+1 TO 6
    SPRITE %55+i,%290,%14+(i*18),53,1
  NEXT %i

  ; wait for a key up
  REPEAT : REPEAT UNTIL INKEY$ =""

ENDPROC
;
DEFPROC dT()
  LET %g=% PEEK 23672
  LET %f=%g-n
  IF %g < n THEN LET %f=%f+256
  LET %n=%g
ENDPROC =%f
;
DEFPROC splash()
  LAYER 2,1: CLS
  .bmpload assets/welcome.bmp
  PAUSE 0
  LAYER CLEAR : PALETTE CLEAR
ENDPROC
;
DEFPROC optionsScreen()
  PROC header()

  LET %y=7
  DIFFICULTY=0
  %z=0

  PRINT AT %y+1,5;"Speed of baddies [1-5] ? █"
  PRINT AT %y+2,5;"    (1 is fastest)"
  PAUSE 100
  REPEAT
    SPRITE MOVE INT
    LET %j=% INT { CODE INKEY$ }-$30
    IF %j < 6 THEN %z=%j
  REPEAT UNTIL %z <> 0
  PRINT AT %y+1,30;%z
  SPEED=%z
  %z=%S( INT {SPEED})
  REPEAT : REPEAT UNTIL INKEY$ ="": ; wait until the key is up again

  PRINT AT %y+4,5;"Difficulty level [1-5] ? █"
  PRINT AT %y+5,5;"    (1 is hardest)"
  REPEAT
    SPRITE MOVE INT
    LET %j=% INT { CODE INKEY$ }-$30
    IF %j < 6 THEN DIFFICULTY=%j
  REPEAT UNTIL DIFFICULTY <> 0
  PRINT AT %y+4,30;DIFFICULTY

  REPEAT : REPEAT UNTIL INKEY$ ="": ; wait until the key is up again

  MUSIC=2
  PRINT AT %y+7,5;"Background music [Y-N] ? █"
  REPEAT
    SPRITE MOVE INT
    c$= INKEY$
    IF c$="n" THEN MUSIC=0: PRINT AT %y+7,30;"No"
    IF c$="y" THEN MUSIC=1: PRINT AT %y+7,30;"Yes"
  REPEAT UNTIL MUSIC < 2

  IF MUSIC=0 THEN DRIVER 50,4: ELSE DRIVER 50,2: DRIVER 50,3

  REPEAT : REPEAT UNTIL INKEY$ ="": ; wait until the key is up again

ENDPROC
;
DEFPROC creditScreen()
  PROC header()

  LET %y=7

  PRINT AT %y,1;"CREDITS"
  PRINT AT %y+2,1;"Written by Remy Sharp";
  PRINT AT %y+3,1;"https://remysharp.com / @rem"
  PRINT AT %y+5,1;"Sprites by Remy's kids"
  PRINT AT %y+7,1;"Music by Richard Faulkner"
  ; font: https://spectrumcomputing.co.uk/entry/25364/ZX-Spectrum/The_8bit_Font_Collection
  PRINT AT %y+9,1;"Font by Paul van der Laan"

  PAPER 0: INK 252
  PRINT AT %y+13,24;"Continue..."
  PAPER 252: INK 0

  PAUSE 50: REPEAT : SPRITE MOVE INT : REPEAT UNTIL INKEY$ <> ""
ENDPROC
;
DEFPROC helpScreen()
  PROC header()

  LET %y=8
  ; 123456789012345678901234567890123456 (total column count: 36)
  PRINT AT %y,1;"Rescue the original 1984"
  PRINT AT %y+1,1;"archaeologist party from their";
  PRINT AT %y+2,1;"failed pyramid plundering."
  PRINT AT %y+5,1;"Navigate five catacombs, avoiding"
  PRINT AT %y+6,1;"the guardians, rescue those muppets"
  PRINT AT %y+7,1;"and bring them back to Blighty."
  PAPER 0: INK 252
  PRINT AT %y+12,24;"Continue..."
  PAPER 252: INK 0

  PAUSE 50: REPEAT : SPRITE MOVE INT : REPEAT UNTIL INKEY$ <> ""

  LET %y=7

  PROC header()

  ; the tokens from tombs.map
  TILE DIM 27,24,4,8
  TILE 4,3 AT  0,0 TO 2,%y
  TILE 4,3 AT 12,0 TO 2,%y+3
  TILE 4,3 AT 24,0 TO 2,%y+6
  TILE 4,3 AT 48,0 TO 2,%y+9

  PRINT AT %y+1,6;"Rescue this dude"
  PRINT AT %y+4,6;"Key to escape the catacomb"
  PRINT AT %y+7,6;"Vanquish a guardian"
  PRINT AT %y+10,6;"Gems means hi-scores"

  PAPER 0: INK 252
  PRINT AT %y+13,24;"Continue..."
  PAPER 252: INK 0

  PAUSE 50: REPEAT : SPRITE MOVE INT : REPEAT UNTIL INKEY$ <> ""

  PROC header()

  LET %y=7

  PRINT AT %y,2;"CONTROLS"
  PRINT AT %y+2,2;"Kempton joystick and keyboard";
  PRINT AT %y+4,2;"Q= up"
  PRINT AT %y+5,2;"A= down"
  PRINT AT %y+6,2;"O= left"
  PRINT AT %y+7,2;"P= right"

  PRINT AT %y+10,2;"Surround a tomb to reveal the"
  PRINT AT %y+11,2;"contents. Don't get chomped!"

  PAPER 0: INK 252
  PRINT AT %y+13,24;"Continue..."
  PAPER 252: INK 0

  PAUSE 50: REPEAT : SPRITE MOVE INT : REPEAT UNTIL INKEY$ <> ""

  PROC creditScreen()

ENDPROC
;
DEFPROC header()
  PAPER 252: INK 0: BORDER 0
  ; important: I'm not using CLS as this method is faster
  ; otherwise there's a visible screen clear and reset
  BANK 25 COPY TO 9: ; "Oh Mummy header"
  BANK 10 ERASE 252
  BANK 11 ERASE %0,%$3000,252
  BANK 11 ERASE %$3000,%$1000,0: ; last 4k is black
ENDPROC
;
DEFPROC playScreen()
  PROC header()

  LET %y=9

  ; make the font massive :)
  PRINT CHR$ 29; CHR$ 1

  PRINT AT %y,6;"Rescue the archaeologists"
  PRINT AT %y+2,8;"    Save the day!"
  PRINT AT %y+4,8;"   Don't get eaten"
  PRINT AT 0,0; CHR$ 29; CHR$ 0
  BANK 11 ERASE %$2000,%$2000,0: ; last 4k is black
  PRINT AT %y+12,0; PAPER 0; INK 252;"I-Instructions   O-Options    P-Play"

ENDPROC
;
DEFPROC welcome()
  IF DEBUG THEN ENDPROC : ; FIXME remove
  PLAYING=0
  SPRITE CLEAR
  SPRITE BORDER 0
  SPRITE BANK 22
  SPRITE STOP : ; switch to batching (though pretty sure this isn't required)
  SPRITE PRINT 1

  LET %x=304: LET %y=208
  SPRITE 64,%x,%y,48,%@1001
  SPRITE 63,%x,%y,46,1

  SPRITE CONTINUE 64,0 TO %x STEP -8 RUN , STOP ,48 TO 49, BIN 0001000,3,200
  SPRITE CONTINUE 63,0 TO %x STEP -8 RUN , STOP ,46 TO 47, BIN 0001000,3,225

  CLS
  PRINT AT 0,0; CHR$ 30; CHR$ 7; CHR$ 31; CHR$ 7
  PROC playScreen()

  REPEAT
    SPRITE MOVE INT
    c$= INKEY$
    IF c$="i" THEN PROC helpScreen(): PROC playScreen()
    IF c$="o" THEN PROC optionsScreen(): PROC playScreen()
  REPEAT UNTIL c$="p" OR IN 31=16

  LAYER CLEAR

ENDPROC
;
DEFPROC exit()
  ERROR TO err,lin,st
  ON ERROR
  e$= STR$ err
  ; use break to exit mid-game
  IF err > 9 THEN e$= CHR$ (err+55)
  IF err=21 AND PLAYING THEN PROC initNewGame(): PROC mainLoop(): ENDPROC
  IF DEBUG THEN : PRINT CHR$ 30,: PRINT "Error:";e$;", line:";lin;", statement:";st: REPEAT : REPEAT UNTIL INKEY$ ="": REPEAT : REPEAT UNTIL INKEY$ <> ""

  DRIVER 50,4
  .uninstall "assets/nextdaw.drv"
  PALETTE CLEAR
  LAYER CLEAR
  SPRITE CLEAR
  CLS
  BORDER 7
  GO TO 9999
ENDPROC
;
#autoline
9900 CLEAR : PALETTE CLEAR : LAYER CLEAR : SPRITE PRINT 0: SAVE "mummy.bas" LINE 0: STOP
9999 REG 2,1: ; soft reset
